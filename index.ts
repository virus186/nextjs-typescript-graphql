
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Permissions
 * 
 */
export type Permissions = {
  id: string
  slug: string | null
  title: string | null
  actions: string[]
  parents: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
  userId: string | null
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string | null
  name: string | null
  password: string | null
  mobile: string | null
  roleId: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Warehouse
 * 
 */
export type Warehouse = {
  id: string
  title: string | null
  staff: string | null
  addressId: string[]
  incharge: string | null
  userId: string | null
}

/**
 * Model Racks
 * 
 */
export type Racks = {
  id: string
  name: string | null
  code: string | null
  length: string | null
  width: string | null
  height: string | null
  side: string | null
  userId: string | null
  warehouseId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Shelf
 * 
 */
export type Shelf = {
  id: string
  name: string | null
  code: string | null
  length: string | null
  width: string | null
  height: string | null
  side: string | null
  totalSpace: string | null
  availableSpace: string | null
  rackId: string
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  sku: string | null
  title: string | null
  short_desc: string | null
  desc: string | null
  bulletPoints: string[]
  categories: string[]
  variation: string[]
  images: string[]
  price: string[]
  quantity: string[]
  purchase_price: string[]
  userId: string | null
  warehouseId: string
  shelfId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  title: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model RolePermission
 * 
 */
export type RolePermission = {
  id: string
  roleId: string | null
  permissionId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model PO
 * 
 */
export type PO = {
  id: string
  poStatus: string | null
  paymentStatus: string | null
  paindAmount: string | null
  pendingAmount: string | null
  totalPrice: string | null
  totalTax: string | null
  totalDiscount: string | null
  totalTransportation: string | null
  totalExpenses: string | null
  userId: string | null
  vendorId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model POItems
 * 
 */
export type POItems = {
  id: string
  sku: string | null
  title: string | null
  short_desc: string | null
  desc: string | null
  categories: string[]
  variation: string[]
  images: string[]
  price: string[]
  taxRate: string[]
  taxAmount: string[]
  discountAmount: string[]
  quantity: string[]
  poId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Invoice
 * 
 */
export type Invoice = {
  id: string
  invoiceStatus: string | null
  paymentStatus: string | null
  paindAmount: string | null
  pendingAmount: string | null
  totalPrice: string | null
  totalTax: string | null
  totalDiscount: string | null
  totalTransportation: string | null
  totalExpenses: string | null
  buyerId: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model InvoiceItems
 * 
 */
export type InvoiceItems = {
  id: string
  sku: string | null
  title: string | null
  short_desc: string | null
  desc: string | null
  categories: string[]
  variation: string[]
  images: string[]
  price: string[]
  taxRate: string[]
  taxAmount: string[]
  discountAmount: string[]
  quantity: string[]
  invoiceId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  orderStatus: string | null
  paymentStatus: string | null
  paindAmount: string | null
  pendingAmount: string | null
  totalPrice: string | null
  totalTax: string | null
  totalDiscount: string | null
  totalTransportation: string | null
  totalExpenses: string | null
  buyerId: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model OrderItems
 * 
 */
export type OrderItems = {
  id: string
  sku: string | null
  title: string | null
  short_desc: string | null
  desc: string | null
  categories: string[]
  variation: string[]
  images: string[]
  price: string[]
  taxRate: string[]
  taxAmount: string[]
  discountAmount: string[]
  quantity: string[]
  orderId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model PaymentSlips
 * 
 */
export type PaymentSlips = {
  id: string
  paymentType: string | null
  paymentTypeId: string | null
  paidAmount: string | null
  paymentMode: string | null
  paymentStatus: string | null
  paidBy: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: string
  type: string | null
  addressTitle: string | null
  addressLine: string | null
  addressLine1: string | null
  addressLine2: string | null
  landmark: string | null
  city: string | null
  state: string | null
  country: string | null
  pincode: string | null
  mobile: string | null
  userId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Expanses
 * 
 */
export type Expanses = {
  id: string
  title: string | null
  expensesType: string | null
  amount: string | null
  userId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Employee
 * 
 */
export type Employee = {
  id: string
  title: string | null
  departmentId: string
  monthlyPay: string | null
  yearlyPay: string | null
  userId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Department
 * 
 */
export type Department = {
  id: string
  title: string | null
  userId: string
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Attendance
 * 
 */
export type Attendance = {
  id: string
  title: string | null
  from: string | null
  to: string | null
  presents: string | null
  absents: string | null
  paidLeaves: string | null
  salaryId: string | null
  employeeId: string | null
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}

/**
 * Model Salary
 * 
 */
export type Salary = {
  id: string
  title: string | null
  expensesType: string | null
  amount: string | null
  from: string | null
  to: string | null
  employeeId: string
  userId: string | null
  created_at: Date
  updated_at: Date
  deleted_at: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Permissions
 * const permissions = await prisma.permissions.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permissions.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): PrismaPromise<Prisma.JsonObject>;

      /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<GlobalReject>;

  /**
   * `prisma.racks`: Exposes CRUD operations for the **Racks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Racks
    * const racks = await prisma.racks.findMany()
    * ```
    */
  get racks(): Prisma.RacksDelegate<GlobalReject>;

  /**
   * `prisma.shelf`: Exposes CRUD operations for the **Shelf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shelves
    * const shelves = await prisma.shelf.findMany()
    * ```
    */
  get shelf(): Prisma.ShelfDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<GlobalReject>;

  /**
   * `prisma.pO`: Exposes CRUD operations for the **PO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POS
    * const pOS = await prisma.pO.findMany()
    * ```
    */
  get pO(): Prisma.PODelegate<GlobalReject>;

  /**
   * `prisma.pOItems`: Exposes CRUD operations for the **POItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POItems
    * const pOItems = await prisma.pOItems.findMany()
    * ```
    */
  get pOItems(): Prisma.POItemsDelegate<GlobalReject>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject>;

  /**
   * `prisma.invoiceItems`: Exposes CRUD operations for the **InvoiceItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItems.findMany()
    * ```
    */
  get invoiceItems(): Prisma.InvoiceItemsDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderItems`: Exposes CRUD operations for the **OrderItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItems.findMany()
    * ```
    */
  get orderItems(): Prisma.OrderItemsDelegate<GlobalReject>;

  /**
   * `prisma.paymentSlips`: Exposes CRUD operations for the **PaymentSlips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentSlips
    * const paymentSlips = await prisma.paymentSlips.findMany()
    * ```
    */
  get paymentSlips(): Prisma.PaymentSlipsDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.expanses`: Exposes CRUD operations for the **Expanses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expanses
    * const expanses = await prisma.expanses.findMany()
    * ```
    */
  get expanses(): Prisma.ExpansesDelegate<GlobalReject>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<GlobalReject>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<GlobalReject>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<GlobalReject>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **Salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.SalaryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Prisma Client JS version: 3.15.2
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Permissions: 'Permissions',
    User: 'User',
    Warehouse: 'Warehouse',
    Racks: 'Racks',
    Shelf: 'Shelf',
    Product: 'Product',
    Role: 'Role',
    RolePermission: 'RolePermission',
    PO: 'PO',
    POItems: 'POItems',
    Invoice: 'Invoice',
    InvoiceItems: 'InvoiceItems',
    Order: 'Order',
    OrderItems: 'OrderItems',
    PaymentSlips: 'PaymentSlips',
    Address: 'Address',
    Expanses: 'Expanses',
    Employee: 'Employee',
    Department: 'Department',
    Attendance: 'Attendance',
    Salary: 'Salary'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PermissionsCountOutputType
   */


  export type PermissionsCountOutputType = {
    RolePermission: number
  }

  export type PermissionsCountOutputTypeSelect = {
    RolePermission?: boolean
  }

  export type PermissionsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PermissionsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PermissionsCountOutputType
    : S extends undefined
    ? never
    : S extends PermissionsCountOutputTypeArgs
    ?'include' extends U
    ? PermissionsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PermissionsCountOutputType ? PermissionsCountOutputType[P] : never
  } 
    : PermissionsCountOutputType
  : PermissionsCountOutputType




  // Custom InputTypes

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     * 
    **/
    select?: PermissionsCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    address: number
    permission: number
    expenses: number
    employees: number
    departments: number
  }

  export type UserCountOutputTypeSelect = {
    address?: boolean
    permission?: boolean
    expenses?: boolean
    employees?: boolean
    departments?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type WarehouseCountOutputType
   */


  export type WarehouseCountOutputType = {
    products: number
    racks: number
  }

  export type WarehouseCountOutputTypeSelect = {
    products?: boolean
    racks?: boolean
  }

  export type WarehouseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WarehouseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WarehouseCountOutputType
    : S extends undefined
    ? never
    : S extends WarehouseCountOutputTypeArgs
    ?'include' extends U
    ? WarehouseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WarehouseCountOutputType ? WarehouseCountOutputType[P] : never
  } 
    : WarehouseCountOutputType
  : WarehouseCountOutputType




  // Custom InputTypes

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     * 
    **/
    select?: WarehouseCountOutputTypeSelect | null
  }



  /**
   * Count Type RacksCountOutputType
   */


  export type RacksCountOutputType = {
    shelf: number
  }

  export type RacksCountOutputTypeSelect = {
    shelf?: boolean
  }

  export type RacksCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RacksCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RacksCountOutputType
    : S extends undefined
    ? never
    : S extends RacksCountOutputTypeArgs
    ?'include' extends U
    ? RacksCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RacksCountOutputType ? RacksCountOutputType[P] : never
  } 
    : RacksCountOutputType
  : RacksCountOutputType




  // Custom InputTypes

  /**
   * RacksCountOutputType without action
   */
  export type RacksCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RacksCountOutputType
     * 
    **/
    select?: RacksCountOutputTypeSelect | null
  }



  /**
   * Count Type ShelfCountOutputType
   */


  export type ShelfCountOutputType = {
    Product: number
  }

  export type ShelfCountOutputTypeSelect = {
    Product?: boolean
  }

  export type ShelfCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShelfCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShelfCountOutputType
    : S extends undefined
    ? never
    : S extends ShelfCountOutputTypeArgs
    ?'include' extends U
    ? ShelfCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShelfCountOutputType ? ShelfCountOutputType[P] : never
  } 
    : ShelfCountOutputType
  : ShelfCountOutputType




  // Custom InputTypes

  /**
   * ShelfCountOutputType without action
   */
  export type ShelfCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShelfCountOutputType
     * 
    **/
    select?: ShelfCountOutputTypeSelect | null
  }



  /**
   * Count Type POCountOutputType
   */


  export type POCountOutputType = {
    poItem: number
  }

  export type POCountOutputTypeSelect = {
    poItem?: boolean
  }

  export type POCountOutputTypeGetPayload<
    S extends boolean | null | undefined | POCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? POCountOutputType
    : S extends undefined
    ? never
    : S extends POCountOutputTypeArgs
    ?'include' extends U
    ? POCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof POCountOutputType ? POCountOutputType[P] : never
  } 
    : POCountOutputType
  : POCountOutputType




  // Custom InputTypes

  /**
   * POCountOutputType without action
   */
  export type POCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the POCountOutputType
     * 
    **/
    select?: POCountOutputTypeSelect | null
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    invoiceItems: number
  }

  export type InvoiceCountOutputTypeSelect = {
    invoiceItems?: boolean
  }

  export type InvoiceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InvoiceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InvoiceCountOutputType
    : S extends undefined
    ? never
    : S extends InvoiceCountOutputTypeArgs
    ?'include' extends U
    ? InvoiceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InvoiceCountOutputType ? InvoiceCountOutputType[P] : never
  } 
    : InvoiceCountOutputType
  : InvoiceCountOutputType




  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     * 
    **/
    select?: InvoiceCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type EmployeeCountOutputType
   */


  export type EmployeeCountOutputType = {
    salary: number
    Attendance: number
  }

  export type EmployeeCountOutputTypeSelect = {
    salary?: boolean
    Attendance?: boolean
  }

  export type EmployeeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmployeeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmployeeCountOutputType
    : S extends undefined
    ? never
    : S extends EmployeeCountOutputTypeArgs
    ?'include' extends U
    ? EmployeeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmployeeCountOutputType ? EmployeeCountOutputType[P] : never
  } 
    : EmployeeCountOutputType
  : EmployeeCountOutputType




  // Custom InputTypes

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     * 
    **/
    select?: EmployeeCountOutputTypeSelect | null
  }



  /**
   * Count Type DepartmentCountOutputType
   */


  export type DepartmentCountOutputType = {
    employees: number
  }

  export type DepartmentCountOutputTypeSelect = {
    employees?: boolean
  }

  export type DepartmentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DepartmentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DepartmentCountOutputType
    : S extends undefined
    ? never
    : S extends DepartmentCountOutputTypeArgs
    ?'include' extends U
    ? DepartmentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DepartmentCountOutputType ? DepartmentCountOutputType[P] : never
  } 
    : DepartmentCountOutputType
  : DepartmentCountOutputType




  // Custom InputTypes

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     * 
    **/
    select?: DepartmentCountOutputTypeSelect | null
  }



  /**
   * Count Type SalaryCountOutputType
   */


  export type SalaryCountOutputType = {
    attendance: number
  }

  export type SalaryCountOutputTypeSelect = {
    attendance?: boolean
  }

  export type SalaryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SalaryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SalaryCountOutputType
    : S extends undefined
    ? never
    : S extends SalaryCountOutputTypeArgs
    ?'include' extends U
    ? SalaryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SalaryCountOutputType ? SalaryCountOutputType[P] : never
  } 
    : SalaryCountOutputType
  : SalaryCountOutputType




  // Custom InputTypes

  /**
   * SalaryCountOutputType without action
   */
  export type SalaryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SalaryCountOutputType
     * 
    **/
    select?: SalaryCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Permissions
   */


  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    parents: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    userId: string | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    parents: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    userId: string | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    actions: number
    parents: number
    created_at: number
    updated_at: number
    deleted_at: number
    userId: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    parents?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    userId?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    parents?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    userId?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    actions?: true
    parents?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    userId?: true
    _all?: true
  }

  export type PermissionsAggregateArgs = {
    /**
     * Filter which Permissions to aggregate.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs = {
    where?: PermissionsWhereInput
    orderBy?: Enumerable<PermissionsOrderByWithAggregationInput>
    by: Array<PermissionsScalarFieldEnum>
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }


  export type PermissionsGroupByOutputType = {
    id: string
    slug: string | null
    title: string | null
    actions: string[]
    parents: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    userId: string | null
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect = {
    id?: boolean
    slug?: boolean
    title?: boolean
    actions?: boolean
    parents?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserArgs
    userId?: boolean
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermissionsCountOutputTypeArgs
  }

  export type PermissionsInclude = {
    User?: boolean | UserArgs
    RolePermission?: boolean | RolePermissionFindManyArgs
    _count?: boolean | PermissionsCountOutputTypeArgs
  }

  export type PermissionsGetPayload<
    S extends boolean | null | undefined | PermissionsArgs,
    U = keyof S
      > = S extends true
        ? Permissions
    : S extends undefined
    ? never
    : S extends PermissionsArgs | PermissionsFindManyArgs
    ?'include' extends U
    ? Permissions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<S['include'][P]>>  :
        P extends '_count' ? PermissionsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'RolePermission' ? Array < RolePermissionGetPayload<S['select'][P]>>  :
        P extends '_count' ? PermissionsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Permissions ? Permissions[P] : never
  } 
    : Permissions
  : Permissions


  type PermissionsCountArgs = Merge<
    Omit<PermissionsFindManyArgs, 'select' | 'include'> & {
      select?: PermissionsCountAggregateInputType | true
    }
  >

  export interface PermissionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permissions'> extends True ? CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>> : CheckSelect<T, Prisma__PermissionsClient<Permissions | null >, Prisma__PermissionsClient<PermissionsGetPayload<T> | null >>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permissions'> extends True ? CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>> : CheckSelect<T, Prisma__PermissionsClient<Permissions | null >, Prisma__PermissionsClient<PermissionsGetPayload<T> | null >>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionsFindManyArgs>(
      args?: SelectSubset<T, PermissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Permissions>>, PrismaPromise<Array<PermissionsGetPayload<T>>>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
    **/
    create<T extends PermissionsCreateArgs>(
      args: SelectSubset<T, PermissionsCreateArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Create many Permissions.
     *     @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permissions = await prisma.permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionsCreateManyArgs>(
      args?: SelectSubset<T, PermissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
    **/
    delete<T extends PermissionsDeleteArgs>(
      args: SelectSubset<T, PermissionsDeleteArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionsUpdateArgs>(
      args: SelectSubset<T, PermissionsUpdateArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionsDeleteManyArgs>(
      args?: SelectSubset<T, PermissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionsUpdateManyArgs>(
      args: SelectSubset<T, PermissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionsUpsertArgs>(
      args: SelectSubset<T, PermissionsUpsertArgs>
    ): CheckSelect<T, Prisma__PermissionsClient<Permissions>, Prisma__PermissionsClient<PermissionsGetPayload<T>>>

    /**
     * Find zero or more Permissions that matches the filter.
     * @param {PermissionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const permissions = await prisma.permissions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PermissionsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Permissions.
     * @param {PermissionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const permissions = await prisma.permissions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PermissionsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    RolePermission<T extends RolePermissionFindManyArgs = {}>(args?: Subset<T, RolePermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RolePermission>>, PrismaPromise<Array<RolePermissionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Throw an Error if a Permissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }


  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Throw an Error if a Permissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     * 
    **/
    distinct?: Enumerable<PermissionsScalarFieldEnum>
  }


  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     * 
    **/
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PermissionsScalarFieldEnum>
  }


  /**
   * Permissions create
   */
  export type PermissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The data needed to create a Permissions.
     * 
    **/
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }


  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs = {
    /**
     * The data used to create many Permissions.
     * 
    **/
    data: Enumerable<PermissionsCreateManyInput>
  }


  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The data needed to update a Permissions.
     * 
    **/
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }


  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs = {
    /**
     * The data used to update Permissions.
     * 
    **/
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     * 
    **/
    where?: PermissionsWhereInput
  }


  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     * 
    **/
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     * 
    **/
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }


  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
    /**
     * Filter which Permissions to delete.
     * 
    **/
    where: PermissionsWhereUniqueInput
  }


  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs = {
    /**
     * Filter which Permissions to delete
     * 
    **/
    where?: PermissionsWhereInput
  }


  /**
   * Permissions findRaw
   */
  export type PermissionsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Permissions aggregateRaw
   */
  export type PermissionsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Permissions without action
   */
  export type PermissionsArgs = {
    /**
     * Select specific fields to fetch from the Permissions
     * 
    **/
    select?: PermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionsInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    mobile: string | null
    roleId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    mobile: string | null
    roleId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    mobile: number
    roleId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    mobile?: true
    roleId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    mobile?: true
    roleId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    mobile?: true
    roleId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string | null
    name: string | null
    password: string | null
    mobile: string | null
    roleId: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    mobile?: boolean
    address?: boolean | AddressFindManyArgs
    permission?: boolean | PermissionsFindManyArgs
    expenses?: boolean | ExpansesFindManyArgs
    employees?: boolean | EmployeeFindManyArgs
    departments?: boolean | DepartmentFindManyArgs
    roleId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    address?: boolean | AddressFindManyArgs
    permission?: boolean | PermissionsFindManyArgs
    expenses?: boolean | ExpansesFindManyArgs
    employees?: boolean | EmployeeFindManyArgs
    departments?: boolean | DepartmentFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'address' ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends 'permission' ? Array < PermissionsGetPayload<S['include'][P]>>  :
        P extends 'expenses' ? Array < ExpansesGetPayload<S['include'][P]>>  :
        P extends 'employees' ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends 'departments' ? Array < DepartmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'address' ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends 'permission' ? Array < PermissionsGetPayload<S['select'][P]>>  :
        P extends 'expenses' ? Array < ExpansesGetPayload<S['select'][P]>>  :
        P extends 'employees' ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends 'departments' ? Array < DepartmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    permission<T extends PermissionsFindManyArgs = {}>(args?: Subset<T, PermissionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Permissions>>, PrismaPromise<Array<PermissionsGetPayload<T>>>>;

    expenses<T extends ExpansesFindManyArgs = {}>(args?: Subset<T, ExpansesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expanses>>, PrismaPromise<Array<ExpansesGetPayload<T>>>>;

    employees<T extends EmployeeFindManyArgs = {}>(args?: Subset<T, EmployeeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>;

    departments<T extends DepartmentFindManyArgs = {}>(args?: Subset<T, DepartmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Department>>, PrismaPromise<Array<DepartmentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Warehouse
   */


  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    title: string | null
    staff: string | null
    incharge: string | null
    userId: string | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    staff: string | null
    incharge: string | null
    userId: string | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    title: number
    staff: number
    addressId: number
    incharge: number
    userId: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    title?: true
    staff?: true
    incharge?: true
    userId?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    title?: true
    staff?: true
    incharge?: true
    userId?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    title?: true
    staff?: true
    addressId?: true
    incharge?: true
    userId?: true
    _all?: true
  }

  export type WarehouseAggregateArgs = {
    /**
     * Filter which Warehouse to aggregate.
     * 
    **/
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     * 
    **/
    orderBy?: Enumerable<WarehouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs = {
    where?: WarehouseWhereInput
    orderBy?: Enumerable<WarehouseOrderByWithAggregationInput>
    by: Array<WarehouseScalarFieldEnum>
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }


  export type WarehouseGroupByOutputType = {
    id: string
    title: string | null
    staff: string | null
    addressId: string[]
    incharge: string | null
    userId: string | null
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect = {
    id?: boolean
    title?: boolean
    staff?: boolean
    addressId?: boolean
    incharge?: boolean
    userId?: boolean
    products?: boolean | ProductFindManyArgs
    racks?: boolean | RacksFindManyArgs
    _count?: boolean | WarehouseCountOutputTypeArgs
  }

  export type WarehouseInclude = {
    products?: boolean | ProductFindManyArgs
    racks?: boolean | RacksFindManyArgs
    _count?: boolean | WarehouseCountOutputTypeArgs
  }

  export type WarehouseGetPayload<
    S extends boolean | null | undefined | WarehouseArgs,
    U = keyof S
      > = S extends true
        ? Warehouse
    : S extends undefined
    ? never
    : S extends WarehouseArgs | WarehouseFindManyArgs
    ?'include' extends U
    ? Warehouse  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'racks' ? Array < RacksGetPayload<S['include'][P]>>  :
        P extends '_count' ? WarehouseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'racks' ? Array < RacksGetPayload<S['select'][P]>>  :
        P extends '_count' ? WarehouseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Warehouse ? Warehouse[P] : never
  } 
    : Warehouse
  : Warehouse


  type WarehouseCountArgs = Merge<
    Omit<WarehouseFindManyArgs, 'select' | 'include'> & {
      select?: WarehouseCountAggregateInputType | true
    }
  >

  export interface WarehouseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WarehouseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WarehouseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Warehouse'> extends True ? CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>> : CheckSelect<T, Prisma__WarehouseClient<Warehouse | null >, Prisma__WarehouseClient<WarehouseGetPayload<T> | null >>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WarehouseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WarehouseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Warehouse'> extends True ? CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>> : CheckSelect<T, Prisma__WarehouseClient<Warehouse | null >, Prisma__WarehouseClient<WarehouseGetPayload<T> | null >>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WarehouseFindManyArgs>(
      args?: SelectSubset<T, WarehouseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Warehouse>>, PrismaPromise<Array<WarehouseGetPayload<T>>>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
    **/
    create<T extends WarehouseCreateArgs>(
      args: SelectSubset<T, WarehouseCreateArgs>
    ): CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>>

    /**
     * Create many Warehouses.
     *     @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     *     @example
     *     // Create many Warehouses
     *     const warehouse = await prisma.warehouse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WarehouseCreateManyArgs>(
      args?: SelectSubset<T, WarehouseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
    **/
    delete<T extends WarehouseDeleteArgs>(
      args: SelectSubset<T, WarehouseDeleteArgs>
    ): CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WarehouseUpdateArgs>(
      args: SelectSubset<T, WarehouseUpdateArgs>
    ): CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WarehouseDeleteManyArgs>(
      args?: SelectSubset<T, WarehouseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WarehouseUpdateManyArgs>(
      args: SelectSubset<T, WarehouseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
    **/
    upsert<T extends WarehouseUpsertArgs>(
      args: SelectSubset<T, WarehouseUpsertArgs>
    ): CheckSelect<T, Prisma__WarehouseClient<Warehouse>, Prisma__WarehouseClient<WarehouseGetPayload<T>>>

    /**
     * Find zero or more Warehouses that matches the filter.
     * @param {WarehouseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const warehouse = await prisma.warehouse.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WarehouseFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Warehouse.
     * @param {WarehouseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const warehouse = await prisma.warehouse.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WarehouseAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WarehouseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    racks<T extends RacksFindManyArgs = {}>(args?: Subset<T, RacksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Racks>>, PrismaPromise<Array<RacksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * Throw an Error if a Warehouse can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Warehouse to fetch.
     * 
    **/
    where: WarehouseWhereUniqueInput
  }


  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * Throw an Error if a Warehouse can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Warehouse to fetch.
     * 
    **/
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     * 
    **/
    orderBy?: Enumerable<WarehouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     * 
    **/
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     * 
    **/
    distinct?: Enumerable<WarehouseScalarFieldEnum>
  }


  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * Filter, which Warehouses to fetch.
     * 
    **/
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     * 
    **/
    orderBy?: Enumerable<WarehouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     * 
    **/
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WarehouseScalarFieldEnum>
  }


  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * The data needed to create a Warehouse.
     * 
    **/
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }


  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs = {
    /**
     * The data used to create many Warehouses.
     * 
    **/
    data: Enumerable<WarehouseCreateManyInput>
  }


  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * The data needed to update a Warehouse.
     * 
    **/
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     * 
    **/
    where: WarehouseWhereUniqueInput
  }


  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs = {
    /**
     * The data used to update Warehouses.
     * 
    **/
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     * 
    **/
    where?: WarehouseWhereInput
  }


  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     * 
    **/
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     * 
    **/
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }


  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
    /**
     * Filter which Warehouse to delete.
     * 
    **/
    where: WarehouseWhereUniqueInput
  }


  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs = {
    /**
     * Filter which Warehouses to delete
     * 
    **/
    where?: WarehouseWhereInput
  }


  /**
   * Warehouse findRaw
   */
  export type WarehouseFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Warehouse aggregateRaw
   */
  export type WarehouseAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Warehouse without action
   */
  export type WarehouseArgs = {
    /**
     * Select specific fields to fetch from the Warehouse
     * 
    **/
    select?: WarehouseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WarehouseInclude | null
  }



  /**
   * Model Racks
   */


  export type AggregateRacks = {
    _count: RacksCountAggregateOutputType | null
    _min: RacksMinAggregateOutputType | null
    _max: RacksMaxAggregateOutputType | null
  }

  export type RacksMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    userId: string | null
    warehouseId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RacksMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    userId: string | null
    warehouseId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RacksCountAggregateOutputType = {
    id: number
    name: number
    code: number
    length: number
    width: number
    height: number
    side: number
    userId: number
    warehouseId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type RacksMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    userId?: true
    warehouseId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RacksMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    userId?: true
    warehouseId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RacksCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    userId?: true
    warehouseId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type RacksAggregateArgs = {
    /**
     * Filter which Racks to aggregate.
     * 
    **/
    where?: RacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     * 
    **/
    orderBy?: Enumerable<RacksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Racks
    **/
    _count?: true | RacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RacksMaxAggregateInputType
  }

  export type GetRacksAggregateType<T extends RacksAggregateArgs> = {
        [P in keyof T & keyof AggregateRacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRacks[P]>
      : GetScalarType<T[P], AggregateRacks[P]>
  }




  export type RacksGroupByArgs = {
    where?: RacksWhereInput
    orderBy?: Enumerable<RacksOrderByWithAggregationInput>
    by: Array<RacksScalarFieldEnum>
    having?: RacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RacksCountAggregateInputType | true
    _min?: RacksMinAggregateInputType
    _max?: RacksMaxAggregateInputType
  }


  export type RacksGroupByOutputType = {
    id: string
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    userId: string | null
    warehouseId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: RacksCountAggregateOutputType | null
    _min: RacksMinAggregateOutputType | null
    _max: RacksMaxAggregateOutputType | null
  }

  type GetRacksGroupByPayload<T extends RacksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RacksGroupByOutputType[P]>
            : GetScalarType<T[P], RacksGroupByOutputType[P]>
        }
      >
    >


  export type RacksSelect = {
    id?: boolean
    name?: boolean
    code?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    side?: boolean
    shelf?: boolean | ShelfFindManyArgs
    userId?: boolean
    warehouse?: boolean | WarehouseArgs
    warehouseId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | RacksCountOutputTypeArgs
  }

  export type RacksInclude = {
    shelf?: boolean | ShelfFindManyArgs
    warehouse?: boolean | WarehouseArgs
    _count?: boolean | RacksCountOutputTypeArgs
  }

  export type RacksGetPayload<
    S extends boolean | null | undefined | RacksArgs,
    U = keyof S
      > = S extends true
        ? Racks
    : S extends undefined
    ? never
    : S extends RacksArgs | RacksFindManyArgs
    ?'include' extends U
    ? Racks  & {
    [P in TrueKeys<S['include']>]:
        P extends 'shelf' ? Array < ShelfGetPayload<S['include'][P]>>  :
        P extends 'warehouse' ? WarehouseGetPayload<S['include'][P]> :
        P extends '_count' ? RacksCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'shelf' ? Array < ShelfGetPayload<S['select'][P]>>  :
        P extends 'warehouse' ? WarehouseGetPayload<S['select'][P]> :
        P extends '_count' ? RacksCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Racks ? Racks[P] : never
  } 
    : Racks
  : Racks


  type RacksCountArgs = Merge<
    Omit<RacksFindManyArgs, 'select' | 'include'> & {
      select?: RacksCountAggregateInputType | true
    }
  >

  export interface RacksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Racks that matches the filter.
     * @param {RacksFindUniqueArgs} args - Arguments to find a Racks
     * @example
     * // Get one Racks
     * const racks = await prisma.racks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RacksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RacksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Racks'> extends True ? CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>> : CheckSelect<T, Prisma__RacksClient<Racks | null >, Prisma__RacksClient<RacksGetPayload<T> | null >>

    /**
     * Find the first Racks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksFindFirstArgs} args - Arguments to find a Racks
     * @example
     * // Get one Racks
     * const racks = await prisma.racks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RacksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RacksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Racks'> extends True ? CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>> : CheckSelect<T, Prisma__RacksClient<Racks | null >, Prisma__RacksClient<RacksGetPayload<T> | null >>

    /**
     * Find zero or more Racks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Racks
     * const racks = await prisma.racks.findMany()
     * 
     * // Get first 10 Racks
     * const racks = await prisma.racks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const racksWithIdOnly = await prisma.racks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RacksFindManyArgs>(
      args?: SelectSubset<T, RacksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Racks>>, PrismaPromise<Array<RacksGetPayload<T>>>>

    /**
     * Create a Racks.
     * @param {RacksCreateArgs} args - Arguments to create a Racks.
     * @example
     * // Create one Racks
     * const Racks = await prisma.racks.create({
     *   data: {
     *     // ... data to create a Racks
     *   }
     * })
     * 
    **/
    create<T extends RacksCreateArgs>(
      args: SelectSubset<T, RacksCreateArgs>
    ): CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>>

    /**
     * Create many Racks.
     *     @param {RacksCreateManyArgs} args - Arguments to create many Racks.
     *     @example
     *     // Create many Racks
     *     const racks = await prisma.racks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RacksCreateManyArgs>(
      args?: SelectSubset<T, RacksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Racks.
     * @param {RacksDeleteArgs} args - Arguments to delete one Racks.
     * @example
     * // Delete one Racks
     * const Racks = await prisma.racks.delete({
     *   where: {
     *     // ... filter to delete one Racks
     *   }
     * })
     * 
    **/
    delete<T extends RacksDeleteArgs>(
      args: SelectSubset<T, RacksDeleteArgs>
    ): CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>>

    /**
     * Update one Racks.
     * @param {RacksUpdateArgs} args - Arguments to update one Racks.
     * @example
     * // Update one Racks
     * const racks = await prisma.racks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RacksUpdateArgs>(
      args: SelectSubset<T, RacksUpdateArgs>
    ): CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>>

    /**
     * Delete zero or more Racks.
     * @param {RacksDeleteManyArgs} args - Arguments to filter Racks to delete.
     * @example
     * // Delete a few Racks
     * const { count } = await prisma.racks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RacksDeleteManyArgs>(
      args?: SelectSubset<T, RacksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Racks
     * const racks = await prisma.racks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RacksUpdateManyArgs>(
      args: SelectSubset<T, RacksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Racks.
     * @param {RacksUpsertArgs} args - Arguments to update or create a Racks.
     * @example
     * // Update or create a Racks
     * const racks = await prisma.racks.upsert({
     *   create: {
     *     // ... data to create a Racks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Racks we want to update
     *   }
     * })
    **/
    upsert<T extends RacksUpsertArgs>(
      args: SelectSubset<T, RacksUpsertArgs>
    ): CheckSelect<T, Prisma__RacksClient<Racks>, Prisma__RacksClient<RacksGetPayload<T>>>

    /**
     * Find zero or more Racks that matches the filter.
     * @param {RacksFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const racks = await prisma.racks.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RacksFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Racks.
     * @param {RacksAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const racks = await prisma.racks.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RacksAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksCountArgs} args - Arguments to filter Racks to count.
     * @example
     * // Count the number of Racks
     * const count = await prisma.racks.count({
     *   where: {
     *     // ... the filter for the Racks we want to count
     *   }
     * })
    **/
    count<T extends RacksCountArgs>(
      args?: Subset<T, RacksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RacksAggregateArgs>(args: Subset<T, RacksAggregateArgs>): PrismaPromise<GetRacksAggregateType<T>>

    /**
     * Group by Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RacksGroupByArgs['orderBy'] }
        : { orderBy?: RacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRacksGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Racks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RacksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shelf<T extends ShelfFindManyArgs = {}>(args?: Subset<T, ShelfFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Shelf>>, PrismaPromise<Array<ShelfGetPayload<T>>>>;

    warehouse<T extends WarehouseArgs = {}>(args?: Subset<T, WarehouseArgs>): CheckSelect<T, Prisma__WarehouseClient<Warehouse | null >, Prisma__WarehouseClient<WarehouseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Racks findUnique
   */
  export type RacksFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * Throw an Error if a Racks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Racks to fetch.
     * 
    **/
    where: RacksWhereUniqueInput
  }


  /**
   * Racks findFirst
   */
  export type RacksFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * Throw an Error if a Racks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Racks to fetch.
     * 
    **/
    where?: RacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     * 
    **/
    orderBy?: Enumerable<RacksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Racks.
     * 
    **/
    cursor?: RacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Racks.
     * 
    **/
    distinct?: Enumerable<RacksScalarFieldEnum>
  }


  /**
   * Racks findMany
   */
  export type RacksFindManyArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * Filter, which Racks to fetch.
     * 
    **/
    where?: RacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     * 
    **/
    orderBy?: Enumerable<RacksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Racks.
     * 
    **/
    cursor?: RacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RacksScalarFieldEnum>
  }


  /**
   * Racks create
   */
  export type RacksCreateArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * The data needed to create a Racks.
     * 
    **/
    data: XOR<RacksCreateInput, RacksUncheckedCreateInput>
  }


  /**
   * Racks createMany
   */
  export type RacksCreateManyArgs = {
    /**
     * The data used to create many Racks.
     * 
    **/
    data: Enumerable<RacksCreateManyInput>
  }


  /**
   * Racks update
   */
  export type RacksUpdateArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * The data needed to update a Racks.
     * 
    **/
    data: XOR<RacksUpdateInput, RacksUncheckedUpdateInput>
    /**
     * Choose, which Racks to update.
     * 
    **/
    where: RacksWhereUniqueInput
  }


  /**
   * Racks updateMany
   */
  export type RacksUpdateManyArgs = {
    /**
     * The data used to update Racks.
     * 
    **/
    data: XOR<RacksUpdateManyMutationInput, RacksUncheckedUpdateManyInput>
    /**
     * Filter which Racks to update
     * 
    **/
    where?: RacksWhereInput
  }


  /**
   * Racks upsert
   */
  export type RacksUpsertArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * The filter to search for the Racks to update in case it exists.
     * 
    **/
    where: RacksWhereUniqueInput
    /**
     * In case the Racks found by the `where` argument doesn't exist, create a new Racks with this data.
     * 
    **/
    create: XOR<RacksCreateInput, RacksUncheckedCreateInput>
    /**
     * In case the Racks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RacksUpdateInput, RacksUncheckedUpdateInput>
  }


  /**
   * Racks delete
   */
  export type RacksDeleteArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
    /**
     * Filter which Racks to delete.
     * 
    **/
    where: RacksWhereUniqueInput
  }


  /**
   * Racks deleteMany
   */
  export type RacksDeleteManyArgs = {
    /**
     * Filter which Racks to delete
     * 
    **/
    where?: RacksWhereInput
  }


  /**
   * Racks findRaw
   */
  export type RacksFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Racks aggregateRaw
   */
  export type RacksAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Racks without action
   */
  export type RacksArgs = {
    /**
     * Select specific fields to fetch from the Racks
     * 
    **/
    select?: RacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RacksInclude | null
  }



  /**
   * Model Shelf
   */


  export type AggregateShelf = {
    _count: ShelfCountAggregateOutputType | null
    _min: ShelfMinAggregateOutputType | null
    _max: ShelfMaxAggregateOutputType | null
  }

  export type ShelfMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    totalSpace: string | null
    availableSpace: string | null
    rackId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ShelfMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    totalSpace: string | null
    availableSpace: string | null
    rackId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ShelfCountAggregateOutputType = {
    id: number
    name: number
    code: number
    length: number
    width: number
    height: number
    side: number
    totalSpace: number
    availableSpace: number
    rackId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ShelfMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    totalSpace?: true
    availableSpace?: true
    rackId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ShelfMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    totalSpace?: true
    availableSpace?: true
    rackId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ShelfCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    length?: true
    width?: true
    height?: true
    side?: true
    totalSpace?: true
    availableSpace?: true
    rackId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ShelfAggregateArgs = {
    /**
     * Filter which Shelf to aggregate.
     * 
    **/
    where?: ShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shelves to fetch.
     * 
    **/
    orderBy?: Enumerable<ShelfOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shelves from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shelves.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shelves
    **/
    _count?: true | ShelfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShelfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShelfMaxAggregateInputType
  }

  export type GetShelfAggregateType<T extends ShelfAggregateArgs> = {
        [P in keyof T & keyof AggregateShelf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShelf[P]>
      : GetScalarType<T[P], AggregateShelf[P]>
  }




  export type ShelfGroupByArgs = {
    where?: ShelfWhereInput
    orderBy?: Enumerable<ShelfOrderByWithAggregationInput>
    by: Array<ShelfScalarFieldEnum>
    having?: ShelfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShelfCountAggregateInputType | true
    _min?: ShelfMinAggregateInputType
    _max?: ShelfMaxAggregateInputType
  }


  export type ShelfGroupByOutputType = {
    id: string
    name: string | null
    code: string | null
    length: string | null
    width: string | null
    height: string | null
    side: string | null
    totalSpace: string | null
    availableSpace: string | null
    rackId: string
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: ShelfCountAggregateOutputType | null
    _min: ShelfMinAggregateOutputType | null
    _max: ShelfMaxAggregateOutputType | null
  }

  type GetShelfGroupByPayload<T extends ShelfGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShelfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShelfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShelfGroupByOutputType[P]>
            : GetScalarType<T[P], ShelfGroupByOutputType[P]>
        }
      >
    >


  export type ShelfSelect = {
    id?: boolean
    name?: boolean
    code?: boolean
    length?: boolean
    width?: boolean
    height?: boolean
    side?: boolean
    totalSpace?: boolean
    availableSpace?: boolean
    Product?: boolean | ProductFindManyArgs
    racks?: boolean | RacksArgs
    rackId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | ShelfCountOutputTypeArgs
  }

  export type ShelfInclude = {
    Product?: boolean | ProductFindManyArgs
    racks?: boolean | RacksArgs
    _count?: boolean | ShelfCountOutputTypeArgs
  }

  export type ShelfGetPayload<
    S extends boolean | null | undefined | ShelfArgs,
    U = keyof S
      > = S extends true
        ? Shelf
    : S extends undefined
    ? never
    : S extends ShelfArgs | ShelfFindManyArgs
    ?'include' extends U
    ? Shelf  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'racks' ? RacksGetPayload<S['include'][P]> :
        P extends '_count' ? ShelfCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'racks' ? RacksGetPayload<S['select'][P]> :
        P extends '_count' ? ShelfCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Shelf ? Shelf[P] : never
  } 
    : Shelf
  : Shelf


  type ShelfCountArgs = Merge<
    Omit<ShelfFindManyArgs, 'select' | 'include'> & {
      select?: ShelfCountAggregateInputType | true
    }
  >

  export interface ShelfDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Shelf that matches the filter.
     * @param {ShelfFindUniqueArgs} args - Arguments to find a Shelf
     * @example
     * // Get one Shelf
     * const shelf = await prisma.shelf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShelfFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShelfFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Shelf'> extends True ? CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>> : CheckSelect<T, Prisma__ShelfClient<Shelf | null >, Prisma__ShelfClient<ShelfGetPayload<T> | null >>

    /**
     * Find the first Shelf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfFindFirstArgs} args - Arguments to find a Shelf
     * @example
     * // Get one Shelf
     * const shelf = await prisma.shelf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShelfFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShelfFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Shelf'> extends True ? CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>> : CheckSelect<T, Prisma__ShelfClient<Shelf | null >, Prisma__ShelfClient<ShelfGetPayload<T> | null >>

    /**
     * Find zero or more Shelves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shelves
     * const shelves = await prisma.shelf.findMany()
     * 
     * // Get first 10 Shelves
     * const shelves = await prisma.shelf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shelfWithIdOnly = await prisma.shelf.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShelfFindManyArgs>(
      args?: SelectSubset<T, ShelfFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Shelf>>, PrismaPromise<Array<ShelfGetPayload<T>>>>

    /**
     * Create a Shelf.
     * @param {ShelfCreateArgs} args - Arguments to create a Shelf.
     * @example
     * // Create one Shelf
     * const Shelf = await prisma.shelf.create({
     *   data: {
     *     // ... data to create a Shelf
     *   }
     * })
     * 
    **/
    create<T extends ShelfCreateArgs>(
      args: SelectSubset<T, ShelfCreateArgs>
    ): CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>>

    /**
     * Create many Shelves.
     *     @param {ShelfCreateManyArgs} args - Arguments to create many Shelves.
     *     @example
     *     // Create many Shelves
     *     const shelf = await prisma.shelf.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShelfCreateManyArgs>(
      args?: SelectSubset<T, ShelfCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Shelf.
     * @param {ShelfDeleteArgs} args - Arguments to delete one Shelf.
     * @example
     * // Delete one Shelf
     * const Shelf = await prisma.shelf.delete({
     *   where: {
     *     // ... filter to delete one Shelf
     *   }
     * })
     * 
    **/
    delete<T extends ShelfDeleteArgs>(
      args: SelectSubset<T, ShelfDeleteArgs>
    ): CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>>

    /**
     * Update one Shelf.
     * @param {ShelfUpdateArgs} args - Arguments to update one Shelf.
     * @example
     * // Update one Shelf
     * const shelf = await prisma.shelf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShelfUpdateArgs>(
      args: SelectSubset<T, ShelfUpdateArgs>
    ): CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>>

    /**
     * Delete zero or more Shelves.
     * @param {ShelfDeleteManyArgs} args - Arguments to filter Shelves to delete.
     * @example
     * // Delete a few Shelves
     * const { count } = await prisma.shelf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShelfDeleteManyArgs>(
      args?: SelectSubset<T, ShelfDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shelves
     * const shelf = await prisma.shelf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShelfUpdateManyArgs>(
      args: SelectSubset<T, ShelfUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Shelf.
     * @param {ShelfUpsertArgs} args - Arguments to update or create a Shelf.
     * @example
     * // Update or create a Shelf
     * const shelf = await prisma.shelf.upsert({
     *   create: {
     *     // ... data to create a Shelf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shelf we want to update
     *   }
     * })
    **/
    upsert<T extends ShelfUpsertArgs>(
      args: SelectSubset<T, ShelfUpsertArgs>
    ): CheckSelect<T, Prisma__ShelfClient<Shelf>, Prisma__ShelfClient<ShelfGetPayload<T>>>

    /**
     * Find zero or more Shelves that matches the filter.
     * @param {ShelfFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const shelf = await prisma.shelf.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ShelfFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Shelf.
     * @param {ShelfAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const shelf = await prisma.shelf.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ShelfAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Shelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfCountArgs} args - Arguments to filter Shelves to count.
     * @example
     * // Count the number of Shelves
     * const count = await prisma.shelf.count({
     *   where: {
     *     // ... the filter for the Shelves we want to count
     *   }
     * })
    **/
    count<T extends ShelfCountArgs>(
      args?: Subset<T, ShelfCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShelfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShelfAggregateArgs>(args: Subset<T, ShelfAggregateArgs>): PrismaPromise<GetShelfAggregateType<T>>

    /**
     * Group by Shelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShelfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShelfGroupByArgs['orderBy'] }
        : { orderBy?: ShelfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShelfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShelfGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shelf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShelfClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    racks<T extends RacksArgs = {}>(args?: Subset<T, RacksArgs>): CheckSelect<T, Prisma__RacksClient<Racks | null >, Prisma__RacksClient<RacksGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Shelf findUnique
   */
  export type ShelfFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * Throw an Error if a Shelf can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shelf to fetch.
     * 
    **/
    where: ShelfWhereUniqueInput
  }


  /**
   * Shelf findFirst
   */
  export type ShelfFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * Throw an Error if a Shelf can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shelf to fetch.
     * 
    **/
    where?: ShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shelves to fetch.
     * 
    **/
    orderBy?: Enumerable<ShelfOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shelves.
     * 
    **/
    cursor?: ShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shelves from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shelves.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shelves.
     * 
    **/
    distinct?: Enumerable<ShelfScalarFieldEnum>
  }


  /**
   * Shelf findMany
   */
  export type ShelfFindManyArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * Filter, which Shelves to fetch.
     * 
    **/
    where?: ShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shelves to fetch.
     * 
    **/
    orderBy?: Enumerable<ShelfOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shelves.
     * 
    **/
    cursor?: ShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shelves from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shelves.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShelfScalarFieldEnum>
  }


  /**
   * Shelf create
   */
  export type ShelfCreateArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * The data needed to create a Shelf.
     * 
    **/
    data: XOR<ShelfCreateInput, ShelfUncheckedCreateInput>
  }


  /**
   * Shelf createMany
   */
  export type ShelfCreateManyArgs = {
    /**
     * The data used to create many Shelves.
     * 
    **/
    data: Enumerable<ShelfCreateManyInput>
  }


  /**
   * Shelf update
   */
  export type ShelfUpdateArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * The data needed to update a Shelf.
     * 
    **/
    data: XOR<ShelfUpdateInput, ShelfUncheckedUpdateInput>
    /**
     * Choose, which Shelf to update.
     * 
    **/
    where: ShelfWhereUniqueInput
  }


  /**
   * Shelf updateMany
   */
  export type ShelfUpdateManyArgs = {
    /**
     * The data used to update Shelves.
     * 
    **/
    data: XOR<ShelfUpdateManyMutationInput, ShelfUncheckedUpdateManyInput>
    /**
     * Filter which Shelves to update
     * 
    **/
    where?: ShelfWhereInput
  }


  /**
   * Shelf upsert
   */
  export type ShelfUpsertArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * The filter to search for the Shelf to update in case it exists.
     * 
    **/
    where: ShelfWhereUniqueInput
    /**
     * In case the Shelf found by the `where` argument doesn't exist, create a new Shelf with this data.
     * 
    **/
    create: XOR<ShelfCreateInput, ShelfUncheckedCreateInput>
    /**
     * In case the Shelf was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShelfUpdateInput, ShelfUncheckedUpdateInput>
  }


  /**
   * Shelf delete
   */
  export type ShelfDeleteArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
    /**
     * Filter which Shelf to delete.
     * 
    **/
    where: ShelfWhereUniqueInput
  }


  /**
   * Shelf deleteMany
   */
  export type ShelfDeleteManyArgs = {
    /**
     * Filter which Shelves to delete
     * 
    **/
    where?: ShelfWhereInput
  }


  /**
   * Shelf findRaw
   */
  export type ShelfFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Shelf aggregateRaw
   */
  export type ShelfAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Shelf without action
   */
  export type ShelfArgs = {
    /**
     * Select specific fields to fetch from the Shelf
     * 
    **/
    select?: ShelfSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShelfInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    userId: string | null
    warehouseId: string | null
    shelfId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    userId: string | null
    warehouseId: string | null
    shelfId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    title: number
    short_desc: number
    desc: number
    bulletPoints: number
    categories: number
    variation: number
    images: number
    price: number
    quantity: number
    purchase_price: number
    userId: number
    warehouseId: number
    shelfId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    userId?: true
    warehouseId?: true
    shelfId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    userId?: true
    warehouseId?: true
    shelfId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    bulletPoints?: true
    categories?: true
    variation?: true
    images?: true
    price?: true
    quantity?: true
    purchase_price?: true
    userId?: true
    warehouseId?: true
    shelfId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    bulletPoints: string[]
    categories: string[]
    variation: string[]
    images: string[]
    price: string[]
    quantity: string[]
    purchase_price: string[]
    userId: string | null
    warehouseId: string
    shelfId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    sku?: boolean
    title?: boolean
    short_desc?: boolean
    desc?: boolean
    bulletPoints?: boolean
    categories?: boolean
    variation?: boolean
    images?: boolean
    price?: boolean
    quantity?: boolean
    purchase_price?: boolean
    userId?: boolean
    warehouse?: boolean | WarehouseArgs
    warehouseId?: boolean
    shelf?: boolean | ShelfArgs
    shelfId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ProductInclude = {
    warehouse?: boolean | WarehouseArgs
    shelf?: boolean | ShelfArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'warehouse' ? WarehouseGetPayload<S['include'][P]> :
        P extends 'shelf' ? ShelfGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'warehouse' ? WarehouseGetPayload<S['select'][P]> :
        P extends 'shelf' ? ShelfGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ProductFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ProductAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    warehouse<T extends WarehouseArgs = {}>(args?: Subset<T, WarehouseArgs>): CheckSelect<T, Prisma__WarehouseClient<Warehouse | null >, Prisma__WarehouseClient<WarehouseGetPayload<T> | null >>;

    shelf<T extends ShelfArgs = {}>(args?: Subset<T, ShelfArgs>): CheckSelect<T, Prisma__ShelfClient<Shelf | null >, Prisma__ShelfClient<ShelfGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product findRaw
   */
  export type ProductFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    title: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    title: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    title?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Role ? Role[P] : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Find zero or more Roles that matches the filter.
     * @param {RoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const role = await prisma.role.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RoleFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Role.
     * @param {RoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const role = await prisma.role.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RoleAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role findRaw
   */
  export type RoleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Role aggregateRaw
   */
  export type RoleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
  }



  /**
   * Model RolePermission
   */


  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs = {
    /**
     * Filter which RolePermission to aggregate.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs = {
    where?: RolePermissionWhereInput
    orderBy?: Enumerable<RolePermissionOrderByWithAggregationInput>
    by: Array<RolePermissionScalarFieldEnum>
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }


  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string | null
    permissionId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect = {
    id?: boolean
    roleId?: boolean
    permission?: boolean | PermissionsArgs
    permissionId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type RolePermissionInclude = {
    permission?: boolean | PermissionsArgs
  }

  export type RolePermissionGetPayload<
    S extends boolean | null | undefined | RolePermissionArgs,
    U = keyof S
      > = S extends true
        ? RolePermission
    : S extends undefined
    ? never
    : S extends RolePermissionArgs | RolePermissionFindManyArgs
    ?'include' extends U
    ? RolePermission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'permission' ? PermissionsGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'permission' ? PermissionsGetPayload<S['select'][P]> :  P extends keyof RolePermission ? RolePermission[P] : never
  } 
    : RolePermission
  : RolePermission


  type RolePermissionCountArgs = Merge<
    Omit<RolePermissionFindManyArgs, 'select' | 'include'> & {
      select?: RolePermissionCountAggregateInputType | true
    }
  >

  export interface RolePermissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolePermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolePermissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null >, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null >>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolePermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolePermissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RolePermission'> extends True ? CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionClient<RolePermission | null >, Prisma__RolePermissionClient<RolePermissionGetPayload<T> | null >>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolePermissionFindManyArgs>(
      args?: SelectSubset<T, RolePermissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RolePermission>>, PrismaPromise<Array<RolePermissionGetPayload<T>>>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
    **/
    create<T extends RolePermissionCreateArgs>(
      args: SelectSubset<T, RolePermissionCreateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Create many RolePermissions.
     *     @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     *     @example
     *     // Create many RolePermissions
     *     const rolePermission = await prisma.rolePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolePermissionCreateManyArgs>(
      args?: SelectSubset<T, RolePermissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
    **/
    delete<T extends RolePermissionDeleteArgs>(
      args: SelectSubset<T, RolePermissionDeleteArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolePermissionUpdateArgs>(
      args: SelectSubset<T, RolePermissionUpdateArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolePermissionDeleteManyArgs>(
      args?: SelectSubset<T, RolePermissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolePermissionUpdateManyArgs>(
      args: SelectSubset<T, RolePermissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
    **/
    upsert<T extends RolePermissionUpsertArgs>(
      args: SelectSubset<T, RolePermissionUpsertArgs>
    ): CheckSelect<T, Prisma__RolePermissionClient<RolePermission>, Prisma__RolePermissionClient<RolePermissionGetPayload<T>>>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * @param {RolePermissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rolePermission = await prisma.rolePermission.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RolePermissionFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RolePermission.
     * @param {RolePermissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rolePermission = await prisma.rolePermission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RolePermissionAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolePermissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    permission<T extends PermissionsArgs = {}>(args?: Subset<T, PermissionsArgs>): CheckSelect<T, Prisma__PermissionsClient<Permissions | null >, Prisma__PermissionsClient<PermissionsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Throw an Error if a RolePermission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Throw an Error if a RolePermission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolePermission to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     * 
    **/
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }


  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     * 
    **/
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolePermissionScalarFieldEnum>
  }


  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to create a RolePermission.
     * 
    **/
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }


  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs = {
    /**
     * The data used to create many RolePermissions.
     * 
    **/
    data: Enumerable<RolePermissionCreateManyInput>
  }


  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The data needed to update a RolePermission.
     * 
    **/
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs = {
    /**
     * The data used to update RolePermissions.
     * 
    **/
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     * 
    **/
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     * 
    **/
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }


  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
    /**
     * Filter which RolePermission to delete.
     * 
    **/
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs = {
    /**
     * Filter which RolePermissions to delete
     * 
    **/
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission findRaw
   */
  export type RolePermissionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * RolePermission aggregateRaw
   */
  export type RolePermissionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * RolePermission without action
   */
  export type RolePermissionArgs = {
    /**
     * Select specific fields to fetch from the RolePermission
     * 
    **/
    select?: RolePermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolePermissionInclude | null
  }



  /**
   * Model PO
   */


  export type AggregatePO = {
    _count: POCountAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  export type POMinAggregateOutputType = {
    id: string | null
    poStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    userId: string | null
    vendorId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type POMaxAggregateOutputType = {
    id: string | null
    poStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    userId: string | null
    vendorId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type POCountAggregateOutputType = {
    id: number
    poStatus: number
    paymentStatus: number
    paindAmount: number
    pendingAmount: number
    totalPrice: number
    totalTax: number
    totalDiscount: number
    totalTransportation: number
    totalExpenses: number
    userId: number
    vendorId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type POMinAggregateInputType = {
    id?: true
    poStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    userId?: true
    vendorId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type POMaxAggregateInputType = {
    id?: true
    poStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    userId?: true
    vendorId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type POCountAggregateInputType = {
    id?: true
    poStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    userId?: true
    vendorId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type POAggregateArgs = {
    /**
     * Filter which PO to aggregate.
     * 
    **/
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     * 
    **/
    orderBy?: Enumerable<POOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POS
    **/
    _count?: true | POCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POMaxAggregateInputType
  }

  export type GetPOAggregateType<T extends POAggregateArgs> = {
        [P in keyof T & keyof AggregatePO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePO[P]>
      : GetScalarType<T[P], AggregatePO[P]>
  }




  export type POGroupByArgs = {
    where?: POWhereInput
    orderBy?: Enumerable<POOrderByWithAggregationInput>
    by: Array<POScalarFieldEnum>
    having?: POScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POCountAggregateInputType | true
    _min?: POMinAggregateInputType
    _max?: POMaxAggregateInputType
  }


  export type POGroupByOutputType = {
    id: string
    poStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    userId: string | null
    vendorId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: POCountAggregateOutputType | null
    _min: POMinAggregateOutputType | null
    _max: POMaxAggregateOutputType | null
  }

  type GetPOGroupByPayload<T extends POGroupByArgs> = PrismaPromise<
    Array<
      PickArray<POGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POGroupByOutputType[P]>
            : GetScalarType<T[P], POGroupByOutputType[P]>
        }
      >
    >


  export type POSelect = {
    id?: boolean
    poStatus?: boolean
    paymentStatus?: boolean
    paindAmount?: boolean
    pendingAmount?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscount?: boolean
    totalTransportation?: boolean
    totalExpenses?: boolean
    poItem?: boolean | POItemsFindManyArgs
    userId?: boolean
    vendorId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | POCountOutputTypeArgs
  }

  export type POInclude = {
    poItem?: boolean | POItemsFindManyArgs
    _count?: boolean | POCountOutputTypeArgs
  }

  export type POGetPayload<
    S extends boolean | null | undefined | POArgs,
    U = keyof S
      > = S extends true
        ? PO
    : S extends undefined
    ? never
    : S extends POArgs | POFindManyArgs
    ?'include' extends U
    ? PO  & {
    [P in TrueKeys<S['include']>]:
        P extends 'poItem' ? Array < POItemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? POCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'poItem' ? Array < POItemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? POCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PO ? PO[P] : never
  } 
    : PO
  : PO


  type POCountArgs = Merge<
    Omit<POFindManyArgs, 'select' | 'include'> & {
      select?: POCountAggregateInputType | true
    }
  >

  export interface PODelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PO that matches the filter.
     * @param {POFindUniqueArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, POFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PO'> extends True ? CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>> : CheckSelect<T, Prisma__POClient<PO | null >, Prisma__POClient<POGetPayload<T> | null >>

    /**
     * Find the first PO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindFirstArgs} args - Arguments to find a PO
     * @example
     * // Get one PO
     * const pO = await prisma.pO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, POFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PO'> extends True ? CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>> : CheckSelect<T, Prisma__POClient<PO | null >, Prisma__POClient<POGetPayload<T> | null >>

    /**
     * Find zero or more POS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POS
     * const pOS = await prisma.pO.findMany()
     * 
     * // Get first 10 POS
     * const pOS = await prisma.pO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOWithIdOnly = await prisma.pO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POFindManyArgs>(
      args?: SelectSubset<T, POFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PO>>, PrismaPromise<Array<POGetPayload<T>>>>

    /**
     * Create a PO.
     * @param {POCreateArgs} args - Arguments to create a PO.
     * @example
     * // Create one PO
     * const PO = await prisma.pO.create({
     *   data: {
     *     // ... data to create a PO
     *   }
     * })
     * 
    **/
    create<T extends POCreateArgs>(
      args: SelectSubset<T, POCreateArgs>
    ): CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>>

    /**
     * Create many POS.
     *     @param {POCreateManyArgs} args - Arguments to create many POS.
     *     @example
     *     // Create many POS
     *     const pO = await prisma.pO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POCreateManyArgs>(
      args?: SelectSubset<T, POCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PO.
     * @param {PODeleteArgs} args - Arguments to delete one PO.
     * @example
     * // Delete one PO
     * const PO = await prisma.pO.delete({
     *   where: {
     *     // ... filter to delete one PO
     *   }
     * })
     * 
    **/
    delete<T extends PODeleteArgs>(
      args: SelectSubset<T, PODeleteArgs>
    ): CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>>

    /**
     * Update one PO.
     * @param {POUpdateArgs} args - Arguments to update one PO.
     * @example
     * // Update one PO
     * const pO = await prisma.pO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POUpdateArgs>(
      args: SelectSubset<T, POUpdateArgs>
    ): CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>>

    /**
     * Delete zero or more POS.
     * @param {PODeleteManyArgs} args - Arguments to filter POS to delete.
     * @example
     * // Delete a few POS
     * const { count } = await prisma.pO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PODeleteManyArgs>(
      args?: SelectSubset<T, PODeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POS
     * const pO = await prisma.pO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POUpdateManyArgs>(
      args: SelectSubset<T, POUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PO.
     * @param {POUpsertArgs} args - Arguments to update or create a PO.
     * @example
     * // Update or create a PO
     * const pO = await prisma.pO.upsert({
     *   create: {
     *     // ... data to create a PO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PO we want to update
     *   }
     * })
    **/
    upsert<T extends POUpsertArgs>(
      args: SelectSubset<T, POUpsertArgs>
    ): CheckSelect<T, Prisma__POClient<PO>, Prisma__POClient<POGetPayload<T>>>

    /**
     * Find zero or more POS that matches the filter.
     * @param {POFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pO = await prisma.pO.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: POFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PO.
     * @param {POAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pO = await prisma.pO.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: POAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of POS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POCountArgs} args - Arguments to filter POS to count.
     * @example
     * // Count the number of POS
     * const count = await prisma.pO.count({
     *   where: {
     *     // ... the filter for the POS we want to count
     *   }
     * })
    **/
    count<T extends POCountArgs>(
      args?: Subset<T, POCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POAggregateArgs>(args: Subset<T, POAggregateArgs>): PrismaPromise<GetPOAggregateType<T>>

    /**
     * Group by PO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POGroupByArgs['orderBy'] }
        : { orderBy?: POGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__POClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    poItem<T extends POItemsFindManyArgs = {}>(args?: Subset<T, POItemsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<POItems>>, PrismaPromise<Array<POItemsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PO findUnique
   */
  export type POFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * Throw an Error if a PO can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PO to fetch.
     * 
    **/
    where: POWhereUniqueInput
  }


  /**
   * PO findFirst
   */
  export type POFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * Throw an Error if a PO can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PO to fetch.
     * 
    **/
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     * 
    **/
    orderBy?: Enumerable<POOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POS.
     * 
    **/
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POS.
     * 
    **/
    distinct?: Enumerable<POScalarFieldEnum>
  }


  /**
   * PO findMany
   */
  export type POFindManyArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * Filter, which POS to fetch.
     * 
    **/
    where?: POWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POS to fetch.
     * 
    **/
    orderBy?: Enumerable<POOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POS.
     * 
    **/
    cursor?: POWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<POScalarFieldEnum>
  }


  /**
   * PO create
   */
  export type POCreateArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * The data needed to create a PO.
     * 
    **/
    data: XOR<POCreateInput, POUncheckedCreateInput>
  }


  /**
   * PO createMany
   */
  export type POCreateManyArgs = {
    /**
     * The data used to create many POS.
     * 
    **/
    data: Enumerable<POCreateManyInput>
  }


  /**
   * PO update
   */
  export type POUpdateArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * The data needed to update a PO.
     * 
    **/
    data: XOR<POUpdateInput, POUncheckedUpdateInput>
    /**
     * Choose, which PO to update.
     * 
    **/
    where: POWhereUniqueInput
  }


  /**
   * PO updateMany
   */
  export type POUpdateManyArgs = {
    /**
     * The data used to update POS.
     * 
    **/
    data: XOR<POUpdateManyMutationInput, POUncheckedUpdateManyInput>
    /**
     * Filter which POS to update
     * 
    **/
    where?: POWhereInput
  }


  /**
   * PO upsert
   */
  export type POUpsertArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * The filter to search for the PO to update in case it exists.
     * 
    **/
    where: POWhereUniqueInput
    /**
     * In case the PO found by the `where` argument doesn't exist, create a new PO with this data.
     * 
    **/
    create: XOR<POCreateInput, POUncheckedCreateInput>
    /**
     * In case the PO was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<POUpdateInput, POUncheckedUpdateInput>
  }


  /**
   * PO delete
   */
  export type PODeleteArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
    /**
     * Filter which PO to delete.
     * 
    **/
    where: POWhereUniqueInput
  }


  /**
   * PO deleteMany
   */
  export type PODeleteManyArgs = {
    /**
     * Filter which POS to delete
     * 
    **/
    where?: POWhereInput
  }


  /**
   * PO findRaw
   */
  export type POFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * PO aggregateRaw
   */
  export type POAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * PO without action
   */
  export type POArgs = {
    /**
     * Select specific fields to fetch from the PO
     * 
    **/
    select?: POSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POInclude | null
  }



  /**
   * Model POItems
   */


  export type AggregatePOItems = {
    _count: POItemsCountAggregateOutputType | null
    _min: POItemsMinAggregateOutputType | null
    _max: POItemsMaxAggregateOutputType | null
  }

  export type POItemsMinAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    poId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type POItemsMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    poId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type POItemsCountAggregateOutputType = {
    id: number
    sku: number
    title: number
    short_desc: number
    desc: number
    categories: number
    variation: number
    images: number
    price: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    quantity: number
    poId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type POItemsMinAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    poId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type POItemsMaxAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    poId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type POItemsCountAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    categories?: true
    variation?: true
    images?: true
    price?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    quantity?: true
    poId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type POItemsAggregateArgs = {
    /**
     * Filter which POItems to aggregate.
     * 
    **/
    where?: POItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POItems to fetch.
     * 
    **/
    orderBy?: Enumerable<POItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: POItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POItems
    **/
    _count?: true | POItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POItemsMaxAggregateInputType
  }

  export type GetPOItemsAggregateType<T extends POItemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePOItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOItems[P]>
      : GetScalarType<T[P], AggregatePOItems[P]>
  }




  export type POItemsGroupByArgs = {
    where?: POItemsWhereInput
    orderBy?: Enumerable<POItemsOrderByWithAggregationInput>
    by: Array<POItemsScalarFieldEnum>
    having?: POItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POItemsCountAggregateInputType | true
    _min?: POItemsMinAggregateInputType
    _max?: POItemsMaxAggregateInputType
  }


  export type POItemsGroupByOutputType = {
    id: string
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    categories: string[]
    variation: string[]
    images: string[]
    price: string[]
    taxRate: string[]
    taxAmount: string[]
    discountAmount: string[]
    quantity: string[]
    poId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: POItemsCountAggregateOutputType | null
    _min: POItemsMinAggregateOutputType | null
    _max: POItemsMaxAggregateOutputType | null
  }

  type GetPOItemsGroupByPayload<T extends POItemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<POItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POItemsGroupByOutputType[P]>
            : GetScalarType<T[P], POItemsGroupByOutputType[P]>
        }
      >
    >


  export type POItemsSelect = {
    id?: boolean
    sku?: boolean
    title?: boolean
    short_desc?: boolean
    desc?: boolean
    categories?: boolean
    variation?: boolean
    images?: boolean
    price?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    quantity?: boolean
    po?: boolean | POArgs
    poId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type POItemsInclude = {
    po?: boolean | POArgs
  }

  export type POItemsGetPayload<
    S extends boolean | null | undefined | POItemsArgs,
    U = keyof S
      > = S extends true
        ? POItems
    : S extends undefined
    ? never
    : S extends POItemsArgs | POItemsFindManyArgs
    ?'include' extends U
    ? POItems  & {
    [P in TrueKeys<S['include']>]:
        P extends 'po' ? POGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'po' ? POGetPayload<S['select'][P]> :  P extends keyof POItems ? POItems[P] : never
  } 
    : POItems
  : POItems


  type POItemsCountArgs = Merge<
    Omit<POItemsFindManyArgs, 'select' | 'include'> & {
      select?: POItemsCountAggregateInputType | true
    }
  >

  export interface POItemsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one POItems that matches the filter.
     * @param {POItemsFindUniqueArgs} args - Arguments to find a POItems
     * @example
     * // Get one POItems
     * const pOItems = await prisma.pOItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends POItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, POItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'POItems'> extends True ? CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>> : CheckSelect<T, Prisma__POItemsClient<POItems | null >, Prisma__POItemsClient<POItemsGetPayload<T> | null >>

    /**
     * Find the first POItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsFindFirstArgs} args - Arguments to find a POItems
     * @example
     * // Get one POItems
     * const pOItems = await prisma.pOItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends POItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, POItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'POItems'> extends True ? CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>> : CheckSelect<T, Prisma__POItemsClient<POItems | null >, Prisma__POItemsClient<POItemsGetPayload<T> | null >>

    /**
     * Find zero or more POItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POItems
     * const pOItems = await prisma.pOItems.findMany()
     * 
     * // Get first 10 POItems
     * const pOItems = await prisma.pOItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOItemsWithIdOnly = await prisma.pOItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends POItemsFindManyArgs>(
      args?: SelectSubset<T, POItemsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<POItems>>, PrismaPromise<Array<POItemsGetPayload<T>>>>

    /**
     * Create a POItems.
     * @param {POItemsCreateArgs} args - Arguments to create a POItems.
     * @example
     * // Create one POItems
     * const POItems = await prisma.pOItems.create({
     *   data: {
     *     // ... data to create a POItems
     *   }
     * })
     * 
    **/
    create<T extends POItemsCreateArgs>(
      args: SelectSubset<T, POItemsCreateArgs>
    ): CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>>

    /**
     * Create many POItems.
     *     @param {POItemsCreateManyArgs} args - Arguments to create many POItems.
     *     @example
     *     // Create many POItems
     *     const pOItems = await prisma.pOItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends POItemsCreateManyArgs>(
      args?: SelectSubset<T, POItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a POItems.
     * @param {POItemsDeleteArgs} args - Arguments to delete one POItems.
     * @example
     * // Delete one POItems
     * const POItems = await prisma.pOItems.delete({
     *   where: {
     *     // ... filter to delete one POItems
     *   }
     * })
     * 
    **/
    delete<T extends POItemsDeleteArgs>(
      args: SelectSubset<T, POItemsDeleteArgs>
    ): CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>>

    /**
     * Update one POItems.
     * @param {POItemsUpdateArgs} args - Arguments to update one POItems.
     * @example
     * // Update one POItems
     * const pOItems = await prisma.pOItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends POItemsUpdateArgs>(
      args: SelectSubset<T, POItemsUpdateArgs>
    ): CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>>

    /**
     * Delete zero or more POItems.
     * @param {POItemsDeleteManyArgs} args - Arguments to filter POItems to delete.
     * @example
     * // Delete a few POItems
     * const { count } = await prisma.pOItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends POItemsDeleteManyArgs>(
      args?: SelectSubset<T, POItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more POItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POItems
     * const pOItems = await prisma.pOItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends POItemsUpdateManyArgs>(
      args: SelectSubset<T, POItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one POItems.
     * @param {POItemsUpsertArgs} args - Arguments to update or create a POItems.
     * @example
     * // Update or create a POItems
     * const pOItems = await prisma.pOItems.upsert({
     *   create: {
     *     // ... data to create a POItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POItems we want to update
     *   }
     * })
    **/
    upsert<T extends POItemsUpsertArgs>(
      args: SelectSubset<T, POItemsUpsertArgs>
    ): CheckSelect<T, Prisma__POItemsClient<POItems>, Prisma__POItemsClient<POItemsGetPayload<T>>>

    /**
     * Find zero or more POItems that matches the filter.
     * @param {POItemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pOItems = await prisma.pOItems.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: POItemsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a POItems.
     * @param {POItemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pOItems = await prisma.pOItems.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: POItemsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of POItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsCountArgs} args - Arguments to filter POItems to count.
     * @example
     * // Count the number of POItems
     * const count = await prisma.pOItems.count({
     *   where: {
     *     // ... the filter for the POItems we want to count
     *   }
     * })
    **/
    count<T extends POItemsCountArgs>(
      args?: Subset<T, POItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POItemsAggregateArgs>(args: Subset<T, POItemsAggregateArgs>): PrismaPromise<GetPOItemsAggregateType<T>>

    /**
     * Group by POItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POItemsGroupByArgs['orderBy'] }
        : { orderBy?: POItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOItemsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for POItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__POItemsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    po<T extends POArgs = {}>(args?: Subset<T, POArgs>): CheckSelect<T, Prisma__POClient<PO | null >, Prisma__POClient<POGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * POItems findUnique
   */
  export type POItemsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * Throw an Error if a POItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which POItems to fetch.
     * 
    **/
    where: POItemsWhereUniqueInput
  }


  /**
   * POItems findFirst
   */
  export type POItemsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * Throw an Error if a POItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which POItems to fetch.
     * 
    **/
    where?: POItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POItems to fetch.
     * 
    **/
    orderBy?: Enumerable<POItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POItems.
     * 
    **/
    cursor?: POItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POItems.
     * 
    **/
    distinct?: Enumerable<POItemsScalarFieldEnum>
  }


  /**
   * POItems findMany
   */
  export type POItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * Filter, which POItems to fetch.
     * 
    **/
    where?: POItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POItems to fetch.
     * 
    **/
    orderBy?: Enumerable<POItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POItems.
     * 
    **/
    cursor?: POItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<POItemsScalarFieldEnum>
  }


  /**
   * POItems create
   */
  export type POItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * The data needed to create a POItems.
     * 
    **/
    data: XOR<POItemsCreateInput, POItemsUncheckedCreateInput>
  }


  /**
   * POItems createMany
   */
  export type POItemsCreateManyArgs = {
    /**
     * The data used to create many POItems.
     * 
    **/
    data: Enumerable<POItemsCreateManyInput>
  }


  /**
   * POItems update
   */
  export type POItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * The data needed to update a POItems.
     * 
    **/
    data: XOR<POItemsUpdateInput, POItemsUncheckedUpdateInput>
    /**
     * Choose, which POItems to update.
     * 
    **/
    where: POItemsWhereUniqueInput
  }


  /**
   * POItems updateMany
   */
  export type POItemsUpdateManyArgs = {
    /**
     * The data used to update POItems.
     * 
    **/
    data: XOR<POItemsUpdateManyMutationInput, POItemsUncheckedUpdateManyInput>
    /**
     * Filter which POItems to update
     * 
    **/
    where?: POItemsWhereInput
  }


  /**
   * POItems upsert
   */
  export type POItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * The filter to search for the POItems to update in case it exists.
     * 
    **/
    where: POItemsWhereUniqueInput
    /**
     * In case the POItems found by the `where` argument doesn't exist, create a new POItems with this data.
     * 
    **/
    create: XOR<POItemsCreateInput, POItemsUncheckedCreateInput>
    /**
     * In case the POItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<POItemsUpdateInput, POItemsUncheckedUpdateInput>
  }


  /**
   * POItems delete
   */
  export type POItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
    /**
     * Filter which POItems to delete.
     * 
    **/
    where: POItemsWhereUniqueInput
  }


  /**
   * POItems deleteMany
   */
  export type POItemsDeleteManyArgs = {
    /**
     * Filter which POItems to delete
     * 
    **/
    where?: POItemsWhereInput
  }


  /**
   * POItems findRaw
   */
  export type POItemsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * POItems aggregateRaw
   */
  export type POItemsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * POItems without action
   */
  export type POItemsArgs = {
    /**
     * Select specific fields to fetch from the POItems
     * 
    **/
    select?: POItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: POItemsInclude | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceStatus: number
    paymentStatus: number
    paindAmount: number
    pendingAmount: number
    totalPrice: number
    totalTax: number
    totalDiscount: number
    totalTransportation: number
    totalExpenses: number
    buyerId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs = {
    /**
     * Filter which Invoice to aggregate.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: Array<InvoiceScalarFieldEnum>
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    invoiceStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect = {
    id?: boolean
    invoiceStatus?: boolean
    paymentStatus?: boolean
    paindAmount?: boolean
    pendingAmount?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscount?: boolean
    totalTransportation?: boolean
    totalExpenses?: boolean
    invoiceItems?: boolean | InvoiceItemsFindManyArgs
    buyerId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | InvoiceCountOutputTypeArgs
  }

  export type InvoiceInclude = {
    invoiceItems?: boolean | InvoiceItemsFindManyArgs
    _count?: boolean | InvoiceCountOutputTypeArgs
  }

  export type InvoiceGetPayload<
    S extends boolean | null | undefined | InvoiceArgs,
    U = keyof S
      > = S extends true
        ? Invoice
    : S extends undefined
    ? never
    : S extends InvoiceArgs | InvoiceFindManyArgs
    ?'include' extends U
    ? Invoice  & {
    [P in TrueKeys<S['include']>]:
        P extends 'invoiceItems' ? Array < InvoiceItemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? InvoiceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'invoiceItems' ? Array < InvoiceItemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? InvoiceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Invoice ? Invoice[P] : never
  } 
    : Invoice
  : Invoice


  type InvoiceCountArgs = Merge<
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }
  >

  export interface InvoiceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null >, Prisma__InvoiceClient<InvoiceGetPayload<T> | null >>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceClient<Invoice | null >, Prisma__InvoiceClient<InvoiceGetPayload<T> | null >>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs>(
      args?: SelectSubset<T, InvoiceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Invoice>>, PrismaPromise<Array<InvoiceGetPayload<T>>>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs>(
      args: SelectSubset<T, InvoiceCreateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs>(
      args?: SelectSubset<T, InvoiceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs>(
      args: SelectSubset<T, InvoiceDeleteArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs>(
      args: SelectSubset<T, InvoiceUpdateArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs>(
      args: SelectSubset<T, InvoiceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs>(
      args: SelectSubset<T, InvoiceUpsertArgs>
    ): CheckSelect<T, Prisma__InvoiceClient<Invoice>, Prisma__InvoiceClient<InvoiceGetPayload<T>>>

    /**
     * Find zero or more Invoices that matches the filter.
     * @param {InvoiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invoice = await prisma.invoice.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: InvoiceFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invoice.
     * @param {InvoiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invoice = await prisma.invoice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: InvoiceAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    invoiceItems<T extends InvoiceItemsFindManyArgs = {}>(args?: Subset<T, InvoiceItemsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InvoiceItems>>, PrismaPromise<Array<InvoiceItemsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Throw an Error if a Invoice can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Throw an Error if a Invoice can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Invoice to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     * 
    **/
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter, which Invoices to fetch.
     * 
    **/
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     * 
    **/
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to create a Invoice.
     * 
    **/
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs = {
    /**
     * The data used to create many Invoices.
     * 
    **/
    data: Enumerable<InvoiceCreateManyInput>
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The data needed to update a Invoice.
     * 
    **/
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs = {
    /**
     * The data used to update Invoices.
     * 
    **/
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     * 
    **/
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     * 
    **/
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
    /**
     * Filter which Invoice to delete.
     * 
    **/
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs = {
    /**
     * Filter which Invoices to delete
     * 
    **/
    where?: InvoiceWhereInput
  }


  /**
   * Invoice findRaw
   */
  export type InvoiceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Invoice aggregateRaw
   */
  export type InvoiceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Invoice without action
   */
  export type InvoiceArgs = {
    /**
     * Select specific fields to fetch from the Invoice
     * 
    **/
    select?: InvoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceInclude | null
  }



  /**
   * Model InvoiceItems
   */


  export type AggregateInvoiceItems = {
    _count: InvoiceItemsCountAggregateOutputType | null
    _min: InvoiceItemsMinAggregateOutputType | null
    _max: InvoiceItemsMaxAggregateOutputType | null
  }

  export type InvoiceItemsMinAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    invoiceId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type InvoiceItemsMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    invoiceId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type InvoiceItemsCountAggregateOutputType = {
    id: number
    sku: number
    title: number
    short_desc: number
    desc: number
    categories: number
    variation: number
    images: number
    price: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    quantity: number
    invoiceId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type InvoiceItemsMinAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    invoiceId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type InvoiceItemsMaxAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    invoiceId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type InvoiceItemsCountAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    categories?: true
    variation?: true
    images?: true
    price?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    quantity?: true
    invoiceId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type InvoiceItemsAggregateArgs = {
    /**
     * Filter which InvoiceItems to aggregate.
     * 
    **/
    where?: InvoiceItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InvoiceItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemsMaxAggregateInputType
  }

  export type GetInvoiceItemsAggregateType<T extends InvoiceItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItems[P]>
      : GetScalarType<T[P], AggregateInvoiceItems[P]>
  }




  export type InvoiceItemsGroupByArgs = {
    where?: InvoiceItemsWhereInput
    orderBy?: Enumerable<InvoiceItemsOrderByWithAggregationInput>
    by: Array<InvoiceItemsScalarFieldEnum>
    having?: InvoiceItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemsCountAggregateInputType | true
    _min?: InvoiceItemsMinAggregateInputType
    _max?: InvoiceItemsMaxAggregateInputType
  }


  export type InvoiceItemsGroupByOutputType = {
    id: string
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    categories: string[]
    variation: string[]
    images: string[]
    price: string[]
    taxRate: string[]
    taxAmount: string[]
    discountAmount: string[]
    quantity: string[]
    invoiceId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: InvoiceItemsCountAggregateOutputType | null
    _min: InvoiceItemsMinAggregateOutputType | null
    _max: InvoiceItemsMaxAggregateOutputType | null
  }

  type GetInvoiceItemsGroupByPayload<T extends InvoiceItemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InvoiceItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemsGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemsGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemsSelect = {
    id?: boolean
    sku?: boolean
    title?: boolean
    short_desc?: boolean
    desc?: boolean
    categories?: boolean
    variation?: boolean
    images?: boolean
    price?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    quantity?: boolean
    invoice?: boolean | InvoiceArgs
    invoiceId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type InvoiceItemsInclude = {
    invoice?: boolean | InvoiceArgs
  }

  export type InvoiceItemsGetPayload<
    S extends boolean | null | undefined | InvoiceItemsArgs,
    U = keyof S
      > = S extends true
        ? InvoiceItems
    : S extends undefined
    ? never
    : S extends InvoiceItemsArgs | InvoiceItemsFindManyArgs
    ?'include' extends U
    ? InvoiceItems  & {
    [P in TrueKeys<S['include']>]:
        P extends 'invoice' ? InvoiceGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'invoice' ? InvoiceGetPayload<S['select'][P]> :  P extends keyof InvoiceItems ? InvoiceItems[P] : never
  } 
    : InvoiceItems
  : InvoiceItems


  type InvoiceItemsCountArgs = Merge<
    Omit<InvoiceItemsFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceItemsCountAggregateInputType | true
    }
  >

  export interface InvoiceItemsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one InvoiceItems that matches the filter.
     * @param {InvoiceItemsFindUniqueArgs} args - Arguments to find a InvoiceItems
     * @example
     * // Get one InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InvoiceItems'> extends True ? CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems | null >, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T> | null >>

    /**
     * Find the first InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsFindFirstArgs} args - Arguments to find a InvoiceItems
     * @example
     * // Get one InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InvoiceItems'> extends True ? CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>> : CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems | null >, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T> | null >>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemsWithIdOnly = await prisma.invoiceItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceItemsFindManyArgs>(
      args?: SelectSubset<T, InvoiceItemsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InvoiceItems>>, PrismaPromise<Array<InvoiceItemsGetPayload<T>>>>

    /**
     * Create a InvoiceItems.
     * @param {InvoiceItemsCreateArgs} args - Arguments to create a InvoiceItems.
     * @example
     * // Create one InvoiceItems
     * const InvoiceItems = await prisma.invoiceItems.create({
     *   data: {
     *     // ... data to create a InvoiceItems
     *   }
     * })
     * 
    **/
    create<T extends InvoiceItemsCreateArgs>(
      args: SelectSubset<T, InvoiceItemsCreateArgs>
    ): CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>>

    /**
     * Create many InvoiceItems.
     *     @param {InvoiceItemsCreateManyArgs} args - Arguments to create many InvoiceItems.
     *     @example
     *     // Create many InvoiceItems
     *     const invoiceItems = await prisma.invoiceItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceItemsCreateManyArgs>(
      args?: SelectSubset<T, InvoiceItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceItems.
     * @param {InvoiceItemsDeleteArgs} args - Arguments to delete one InvoiceItems.
     * @example
     * // Delete one InvoiceItems
     * const InvoiceItems = await prisma.invoiceItems.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItems
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceItemsDeleteArgs>(
      args: SelectSubset<T, InvoiceItemsDeleteArgs>
    ): CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>>

    /**
     * Update one InvoiceItems.
     * @param {InvoiceItemsUpdateArgs} args - Arguments to update one InvoiceItems.
     * @example
     * // Update one InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceItemsUpdateArgs>(
      args: SelectSubset<T, InvoiceItemsUpdateArgs>
    ): CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemsDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceItemsDeleteManyArgs>(
      args?: SelectSubset<T, InvoiceItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceItemsUpdateManyArgs>(
      args: SelectSubset<T, InvoiceItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItems.
     * @param {InvoiceItemsUpsertArgs} args - Arguments to update or create a InvoiceItems.
     * @example
     * // Update or create a InvoiceItems
     * const invoiceItems = await prisma.invoiceItems.upsert({
     *   create: {
     *     // ... data to create a InvoiceItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItems we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceItemsUpsertArgs>(
      args: SelectSubset<T, InvoiceItemsUpsertArgs>
    ): CheckSelect<T, Prisma__InvoiceItemsClient<InvoiceItems>, Prisma__InvoiceItemsClient<InvoiceItemsGetPayload<T>>>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * @param {InvoiceItemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invoiceItems = await prisma.invoiceItems.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: InvoiceItemsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a InvoiceItems.
     * @param {InvoiceItemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invoiceItems = await prisma.invoiceItems.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: InvoiceItemsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItems.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemsCountArgs>(
      args?: Subset<T, InvoiceItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemsAggregateArgs>(args: Subset<T, InvoiceItemsAggregateArgs>): PrismaPromise<GetInvoiceItemsAggregateType<T>>

    /**
     * Group by InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemsGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceItemsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    invoice<T extends InvoiceArgs = {}>(args?: Subset<T, InvoiceArgs>): CheckSelect<T, Prisma__InvoiceClient<Invoice | null >, Prisma__InvoiceClient<InvoiceGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * InvoiceItems findUnique
   */
  export type InvoiceItemsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * Throw an Error if a InvoiceItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InvoiceItems to fetch.
     * 
    **/
    where: InvoiceItemsWhereUniqueInput
  }


  /**
   * InvoiceItems findFirst
   */
  export type InvoiceItemsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * Throw an Error if a InvoiceItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InvoiceItems to fetch.
     * 
    **/
    where?: InvoiceItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     * 
    **/
    cursor?: InvoiceItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     * 
    **/
    distinct?: Enumerable<InvoiceItemsScalarFieldEnum>
  }


  /**
   * InvoiceItems findMany
   */
  export type InvoiceItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * Filter, which InvoiceItems to fetch.
     * 
    **/
    where?: InvoiceItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     * 
    **/
    orderBy?: Enumerable<InvoiceItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     * 
    **/
    cursor?: InvoiceItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InvoiceItemsScalarFieldEnum>
  }


  /**
   * InvoiceItems create
   */
  export type InvoiceItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * The data needed to create a InvoiceItems.
     * 
    **/
    data: XOR<InvoiceItemsCreateInput, InvoiceItemsUncheckedCreateInput>
  }


  /**
   * InvoiceItems createMany
   */
  export type InvoiceItemsCreateManyArgs = {
    /**
     * The data used to create many InvoiceItems.
     * 
    **/
    data: Enumerable<InvoiceItemsCreateManyInput>
  }


  /**
   * InvoiceItems update
   */
  export type InvoiceItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * The data needed to update a InvoiceItems.
     * 
    **/
    data: XOR<InvoiceItemsUpdateInput, InvoiceItemsUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItems to update.
     * 
    **/
    where: InvoiceItemsWhereUniqueInput
  }


  /**
   * InvoiceItems updateMany
   */
  export type InvoiceItemsUpdateManyArgs = {
    /**
     * The data used to update InvoiceItems.
     * 
    **/
    data: XOR<InvoiceItemsUpdateManyMutationInput, InvoiceItemsUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     * 
    **/
    where?: InvoiceItemsWhereInput
  }


  /**
   * InvoiceItems upsert
   */
  export type InvoiceItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * The filter to search for the InvoiceItems to update in case it exists.
     * 
    **/
    where: InvoiceItemsWhereUniqueInput
    /**
     * In case the InvoiceItems found by the `where` argument doesn't exist, create a new InvoiceItems with this data.
     * 
    **/
    create: XOR<InvoiceItemsCreateInput, InvoiceItemsUncheckedCreateInput>
    /**
     * In case the InvoiceItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InvoiceItemsUpdateInput, InvoiceItemsUncheckedUpdateInput>
  }


  /**
   * InvoiceItems delete
   */
  export type InvoiceItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
    /**
     * Filter which InvoiceItems to delete.
     * 
    **/
    where: InvoiceItemsWhereUniqueInput
  }


  /**
   * InvoiceItems deleteMany
   */
  export type InvoiceItemsDeleteManyArgs = {
    /**
     * Filter which InvoiceItems to delete
     * 
    **/
    where?: InvoiceItemsWhereInput
  }


  /**
   * InvoiceItems findRaw
   */
  export type InvoiceItemsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * InvoiceItems aggregateRaw
   */
  export type InvoiceItemsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * InvoiceItems without action
   */
  export type InvoiceItemsArgs = {
    /**
     * Select specific fields to fetch from the InvoiceItems
     * 
    **/
    select?: InvoiceItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InvoiceItemsInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderStatus: number
    paymentStatus: number
    paindAmount: number
    pendingAmount: number
    totalPrice: number
    totalTax: number
    totalDiscount: number
    totalTransportation: number
    totalExpenses: number
    buyerId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    orderStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderStatus?: true
    paymentStatus?: true
    paindAmount?: true
    pendingAmount?: true
    totalPrice?: true
    totalTax?: true
    totalDiscount?: true
    totalTransportation?: true
    totalExpenses?: true
    buyerId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    orderStatus: string | null
    paymentStatus: string | null
    paindAmount: string | null
    pendingAmount: string | null
    totalPrice: string | null
    totalTax: string | null
    totalDiscount: string | null
    totalTransportation: string | null
    totalExpenses: string | null
    buyerId: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    orderStatus?: boolean
    paymentStatus?: boolean
    paindAmount?: boolean
    pendingAmount?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscount?: boolean
    totalTransportation?: boolean
    totalExpenses?: boolean
    orderItems?: boolean | OrderItemsFindManyArgs
    buyerId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    orderItems?: boolean | OrderItemsFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'orderItems' ? Array < OrderItemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'orderItems' ? Array < OrderItemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OrderFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OrderAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orderItems<T extends OrderItemsFindManyArgs = {}>(args?: Subset<T, OrderItemsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItems>>, PrismaPromise<Array<OrderItemsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order findRaw
   */
  export type OrderFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model OrderItems
   */


  export type AggregateOrderItems = {
    _count: OrderItemsCountAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  export type OrderItemsMinAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    orderId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type OrderItemsMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    orderId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type OrderItemsCountAggregateOutputType = {
    id: number
    sku: number
    title: number
    short_desc: number
    desc: number
    categories: number
    variation: number
    images: number
    price: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    quantity: number
    orderId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type OrderItemsMinAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    orderId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type OrderItemsMaxAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    orderId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type OrderItemsCountAggregateInputType = {
    id?: true
    sku?: true
    title?: true
    short_desc?: true
    desc?: true
    categories?: true
    variation?: true
    images?: true
    price?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    quantity?: true
    orderId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type OrderItemsAggregateArgs = {
    /**
     * Filter which OrderItems to aggregate.
     * 
    **/
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemsMaxAggregateInputType
  }

  export type GetOrderItemsAggregateType<T extends OrderItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItems[P]>
      : GetScalarType<T[P], AggregateOrderItems[P]>
  }




  export type OrderItemsGroupByArgs = {
    where?: OrderItemsWhereInput
    orderBy?: Enumerable<OrderItemsOrderByWithAggregationInput>
    by: Array<OrderItemsScalarFieldEnum>
    having?: OrderItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemsCountAggregateInputType | true
    _min?: OrderItemsMinAggregateInputType
    _max?: OrderItemsMaxAggregateInputType
  }


  export type OrderItemsGroupByOutputType = {
    id: string
    sku: string | null
    title: string | null
    short_desc: string | null
    desc: string | null
    categories: string[]
    variation: string[]
    images: string[]
    price: string[]
    taxRate: string[]
    taxAmount: string[]
    discountAmount: string[]
    quantity: string[]
    orderId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: OrderItemsCountAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  type GetOrderItemsGroupByPayload<T extends OrderItemsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemsSelect = {
    id?: boolean
    sku?: boolean
    title?: boolean
    short_desc?: boolean
    desc?: boolean
    categories?: boolean
    variation?: boolean
    images?: boolean
    price?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    quantity?: boolean
    order?: boolean | OrderArgs
    orderId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type OrderItemsInclude = {
    order?: boolean | OrderArgs
  }

  export type OrderItemsGetPayload<
    S extends boolean | null | undefined | OrderItemsArgs,
    U = keyof S
      > = S extends true
        ? OrderItems
    : S extends undefined
    ? never
    : S extends OrderItemsArgs | OrderItemsFindManyArgs
    ?'include' extends U
    ? OrderItems  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<S['select'][P]> :  P extends keyof OrderItems ? OrderItems[P] : never
  } 
    : OrderItems
  : OrderItems


  type OrderItemsCountArgs = Merge<
    Omit<OrderItemsFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemsCountAggregateInputType | true
    }
  >

  export interface OrderItemsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrderItems that matches the filter.
     * @param {OrderItemsFindUniqueArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderItems'> extends True ? CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemsClient<OrderItems | null >, Prisma__OrderItemsClient<OrderItemsGetPayload<T> | null >>

    /**
     * Find the first OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderItems'> extends True ? CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemsClient<OrderItems | null >, Prisma__OrderItemsClient<OrderItemsGetPayload<T> | null >>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItems.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemsWithIdOnly = await prisma.orderItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderItemsFindManyArgs>(
      args?: SelectSubset<T, OrderItemsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderItems>>, PrismaPromise<Array<OrderItemsGetPayload<T>>>>

    /**
     * Create a OrderItems.
     * @param {OrderItemsCreateArgs} args - Arguments to create a OrderItems.
     * @example
     * // Create one OrderItems
     * const OrderItems = await prisma.orderItems.create({
     *   data: {
     *     // ... data to create a OrderItems
     *   }
     * })
     * 
    **/
    create<T extends OrderItemsCreateArgs>(
      args: SelectSubset<T, OrderItemsCreateArgs>
    ): CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>>

    /**
     * Create many OrderItems.
     *     @param {OrderItemsCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItems = await prisma.orderItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemsCreateManyArgs>(
      args?: SelectSubset<T, OrderItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItems.
     * @param {OrderItemsDeleteArgs} args - Arguments to delete one OrderItems.
     * @example
     * // Delete one OrderItems
     * const OrderItems = await prisma.orderItems.delete({
     *   where: {
     *     // ... filter to delete one OrderItems
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemsDeleteArgs>(
      args: SelectSubset<T, OrderItemsDeleteArgs>
    ): CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>>

    /**
     * Update one OrderItems.
     * @param {OrderItemsUpdateArgs} args - Arguments to update one OrderItems.
     * @example
     * // Update one OrderItems
     * const orderItems = await prisma.orderItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemsUpdateArgs>(
      args: SelectSubset<T, OrderItemsUpdateArgs>
    ): CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemsDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemsDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItems = await prisma.orderItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemsUpdateManyArgs>(
      args: SelectSubset<T, OrderItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItems.
     * @param {OrderItemsUpsertArgs} args - Arguments to update or create a OrderItems.
     * @example
     * // Update or create a OrderItems
     * const orderItems = await prisma.orderItems.upsert({
     *   create: {
     *     // ... data to create a OrderItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItems we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemsUpsertArgs>(
      args: SelectSubset<T, OrderItemsUpsertArgs>
    ): CheckSelect<T, Prisma__OrderItemsClient<OrderItems>, Prisma__OrderItemsClient<OrderItemsGetPayload<T>>>

    /**
     * Find zero or more OrderItems that matches the filter.
     * @param {OrderItemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const orderItems = await prisma.orderItems.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OrderItemsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OrderItems.
     * @param {OrderItemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const orderItems = await prisma.orderItems.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OrderItemsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItems.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemsCountArgs>(
      args?: Subset<T, OrderItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemsAggregateArgs>(args: Subset<T, OrderItemsAggregateArgs>): PrismaPromise<GetOrderItemsAggregateType<T>>

    /**
     * Group by OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemsGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrderItems findUnique
   */
  export type OrderItemsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * Throw an Error if a OrderItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderItems to fetch.
     * 
    **/
    where: OrderItemsWhereUniqueInput
  }


  /**
   * OrderItems findFirst
   */
  export type OrderItemsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * Throw an Error if a OrderItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderItems to fetch.
     * 
    **/
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     * 
    **/
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     * 
    **/
    distinct?: Enumerable<OrderItemsScalarFieldEnum>
  }


  /**
   * OrderItems findMany
   */
  export type OrderItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * Filter, which OrderItems to fetch.
     * 
    **/
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     * 
    **/
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderItemsScalarFieldEnum>
  }


  /**
   * OrderItems create
   */
  export type OrderItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * The data needed to create a OrderItems.
     * 
    **/
    data: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
  }


  /**
   * OrderItems createMany
   */
  export type OrderItemsCreateManyArgs = {
    /**
     * The data used to create many OrderItems.
     * 
    **/
    data: Enumerable<OrderItemsCreateManyInput>
  }


  /**
   * OrderItems update
   */
  export type OrderItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * The data needed to update a OrderItems.
     * 
    **/
    data: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
    /**
     * Choose, which OrderItems to update.
     * 
    **/
    where: OrderItemsWhereUniqueInput
  }


  /**
   * OrderItems updateMany
   */
  export type OrderItemsUpdateManyArgs = {
    /**
     * The data used to update OrderItems.
     * 
    **/
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     * 
    **/
    where?: OrderItemsWhereInput
  }


  /**
   * OrderItems upsert
   */
  export type OrderItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * The filter to search for the OrderItems to update in case it exists.
     * 
    **/
    where: OrderItemsWhereUniqueInput
    /**
     * In case the OrderItems found by the `where` argument doesn't exist, create a new OrderItems with this data.
     * 
    **/
    create: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
    /**
     * In case the OrderItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
  }


  /**
   * OrderItems delete
   */
  export type OrderItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
    /**
     * Filter which OrderItems to delete.
     * 
    **/
    where: OrderItemsWhereUniqueInput
  }


  /**
   * OrderItems deleteMany
   */
  export type OrderItemsDeleteManyArgs = {
    /**
     * Filter which OrderItems to delete
     * 
    **/
    where?: OrderItemsWhereInput
  }


  /**
   * OrderItems findRaw
   */
  export type OrderItemsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * OrderItems aggregateRaw
   */
  export type OrderItemsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * OrderItems without action
   */
  export type OrderItemsArgs = {
    /**
     * Select specific fields to fetch from the OrderItems
     * 
    **/
    select?: OrderItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemsInclude | null
  }



  /**
   * Model PaymentSlips
   */


  export type AggregatePaymentSlips = {
    _count: PaymentSlipsCountAggregateOutputType | null
    _min: PaymentSlipsMinAggregateOutputType | null
    _max: PaymentSlipsMaxAggregateOutputType | null
  }

  export type PaymentSlipsMinAggregateOutputType = {
    id: string | null
    paymentType: string | null
    paymentTypeId: string | null
    paidAmount: string | null
    paymentMode: string | null
    paymentStatus: string | null
    paidBy: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PaymentSlipsMaxAggregateOutputType = {
    id: string | null
    paymentType: string | null
    paymentTypeId: string | null
    paidAmount: string | null
    paymentMode: string | null
    paymentStatus: string | null
    paidBy: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PaymentSlipsCountAggregateOutputType = {
    id: number
    paymentType: number
    paymentTypeId: number
    paidAmount: number
    paymentMode: number
    paymentStatus: number
    paidBy: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type PaymentSlipsMinAggregateInputType = {
    id?: true
    paymentType?: true
    paymentTypeId?: true
    paidAmount?: true
    paymentMode?: true
    paymentStatus?: true
    paidBy?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PaymentSlipsMaxAggregateInputType = {
    id?: true
    paymentType?: true
    paymentTypeId?: true
    paidAmount?: true
    paymentMode?: true
    paymentStatus?: true
    paidBy?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PaymentSlipsCountAggregateInputType = {
    id?: true
    paymentType?: true
    paymentTypeId?: true
    paidAmount?: true
    paymentMode?: true
    paymentStatus?: true
    paidBy?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type PaymentSlipsAggregateArgs = {
    /**
     * Filter which PaymentSlips to aggregate.
     * 
    **/
    where?: PaymentSlipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSlips to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentSlipsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentSlipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSlips from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSlips.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentSlips
    **/
    _count?: true | PaymentSlipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentSlipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentSlipsMaxAggregateInputType
  }

  export type GetPaymentSlipsAggregateType<T extends PaymentSlipsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentSlips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentSlips[P]>
      : GetScalarType<T[P], AggregatePaymentSlips[P]>
  }




  export type PaymentSlipsGroupByArgs = {
    where?: PaymentSlipsWhereInput
    orderBy?: Enumerable<PaymentSlipsOrderByWithAggregationInput>
    by: Array<PaymentSlipsScalarFieldEnum>
    having?: PaymentSlipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentSlipsCountAggregateInputType | true
    _min?: PaymentSlipsMinAggregateInputType
    _max?: PaymentSlipsMaxAggregateInputType
  }


  export type PaymentSlipsGroupByOutputType = {
    id: string
    paymentType: string | null
    paymentTypeId: string | null
    paidAmount: string | null
    paymentMode: string | null
    paymentStatus: string | null
    paidBy: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: PaymentSlipsCountAggregateOutputType | null
    _min: PaymentSlipsMinAggregateOutputType | null
    _max: PaymentSlipsMaxAggregateOutputType | null
  }

  type GetPaymentSlipsGroupByPayload<T extends PaymentSlipsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentSlipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentSlipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentSlipsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentSlipsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSlipsSelect = {
    id?: boolean
    paymentType?: boolean
    paymentTypeId?: boolean
    paidAmount?: boolean
    paymentMode?: boolean
    paymentStatus?: boolean
    paidBy?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type PaymentSlipsGetPayload<
    S extends boolean | null | undefined | PaymentSlipsArgs,
    U = keyof S
      > = S extends true
        ? PaymentSlips
    : S extends undefined
    ? never
    : S extends PaymentSlipsArgs | PaymentSlipsFindManyArgs
    ?'include' extends U
    ? PaymentSlips 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PaymentSlips ? PaymentSlips[P] : never
  } 
    : PaymentSlips
  : PaymentSlips


  type PaymentSlipsCountArgs = Merge<
    Omit<PaymentSlipsFindManyArgs, 'select' | 'include'> & {
      select?: PaymentSlipsCountAggregateInputType | true
    }
  >

  export interface PaymentSlipsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PaymentSlips that matches the filter.
     * @param {PaymentSlipsFindUniqueArgs} args - Arguments to find a PaymentSlips
     * @example
     * // Get one PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentSlipsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentSlipsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentSlips'> extends True ? CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>> : CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips | null >, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T> | null >>

    /**
     * Find the first PaymentSlips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsFindFirstArgs} args - Arguments to find a PaymentSlips
     * @example
     * // Get one PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentSlipsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentSlipsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentSlips'> extends True ? CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>> : CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips | null >, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T> | null >>

    /**
     * Find zero or more PaymentSlips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.findMany()
     * 
     * // Get first 10 PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentSlipsWithIdOnly = await prisma.paymentSlips.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentSlipsFindManyArgs>(
      args?: SelectSubset<T, PaymentSlipsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PaymentSlips>>, PrismaPromise<Array<PaymentSlipsGetPayload<T>>>>

    /**
     * Create a PaymentSlips.
     * @param {PaymentSlipsCreateArgs} args - Arguments to create a PaymentSlips.
     * @example
     * // Create one PaymentSlips
     * const PaymentSlips = await prisma.paymentSlips.create({
     *   data: {
     *     // ... data to create a PaymentSlips
     *   }
     * })
     * 
    **/
    create<T extends PaymentSlipsCreateArgs>(
      args: SelectSubset<T, PaymentSlipsCreateArgs>
    ): CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>>

    /**
     * Create many PaymentSlips.
     *     @param {PaymentSlipsCreateManyArgs} args - Arguments to create many PaymentSlips.
     *     @example
     *     // Create many PaymentSlips
     *     const paymentSlips = await prisma.paymentSlips.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentSlipsCreateManyArgs>(
      args?: SelectSubset<T, PaymentSlipsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentSlips.
     * @param {PaymentSlipsDeleteArgs} args - Arguments to delete one PaymentSlips.
     * @example
     * // Delete one PaymentSlips
     * const PaymentSlips = await prisma.paymentSlips.delete({
     *   where: {
     *     // ... filter to delete one PaymentSlips
     *   }
     * })
     * 
    **/
    delete<T extends PaymentSlipsDeleteArgs>(
      args: SelectSubset<T, PaymentSlipsDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>>

    /**
     * Update one PaymentSlips.
     * @param {PaymentSlipsUpdateArgs} args - Arguments to update one PaymentSlips.
     * @example
     * // Update one PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentSlipsUpdateArgs>(
      args: SelectSubset<T, PaymentSlipsUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>>

    /**
     * Delete zero or more PaymentSlips.
     * @param {PaymentSlipsDeleteManyArgs} args - Arguments to filter PaymentSlips to delete.
     * @example
     * // Delete a few PaymentSlips
     * const { count } = await prisma.paymentSlips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentSlipsDeleteManyArgs>(
      args?: SelectSubset<T, PaymentSlipsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentSlipsUpdateManyArgs>(
      args: SelectSubset<T, PaymentSlipsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentSlips.
     * @param {PaymentSlipsUpsertArgs} args - Arguments to update or create a PaymentSlips.
     * @example
     * // Update or create a PaymentSlips
     * const paymentSlips = await prisma.paymentSlips.upsert({
     *   create: {
     *     // ... data to create a PaymentSlips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentSlips we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentSlipsUpsertArgs>(
      args: SelectSubset<T, PaymentSlipsUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentSlipsClient<PaymentSlips>, Prisma__PaymentSlipsClient<PaymentSlipsGetPayload<T>>>

    /**
     * Find zero or more PaymentSlips that matches the filter.
     * @param {PaymentSlipsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const paymentSlips = await prisma.paymentSlips.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PaymentSlipsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PaymentSlips.
     * @param {PaymentSlipsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const paymentSlips = await prisma.paymentSlips.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PaymentSlipsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of PaymentSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsCountArgs} args - Arguments to filter PaymentSlips to count.
     * @example
     * // Count the number of PaymentSlips
     * const count = await prisma.paymentSlips.count({
     *   where: {
     *     // ... the filter for the PaymentSlips we want to count
     *   }
     * })
    **/
    count<T extends PaymentSlipsCountArgs>(
      args?: Subset<T, PaymentSlipsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentSlipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentSlipsAggregateArgs>(args: Subset<T, PaymentSlipsAggregateArgs>): PrismaPromise<GetPaymentSlipsAggregateType<T>>

    /**
     * Group by PaymentSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentSlipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentSlipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentSlipsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentSlipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentSlipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentSlipsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentSlips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentSlipsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PaymentSlips findUnique
   */
  export type PaymentSlipsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * Throw an Error if a PaymentSlips can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PaymentSlips to fetch.
     * 
    **/
    where: PaymentSlipsWhereUniqueInput
  }


  /**
   * PaymentSlips findFirst
   */
  export type PaymentSlipsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * Throw an Error if a PaymentSlips can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PaymentSlips to fetch.
     * 
    **/
    where?: PaymentSlipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSlips to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentSlipsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentSlips.
     * 
    **/
    cursor?: PaymentSlipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSlips from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSlips.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentSlips.
     * 
    **/
    distinct?: Enumerable<PaymentSlipsScalarFieldEnum>
  }


  /**
   * PaymentSlips findMany
   */
  export type PaymentSlipsFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * Filter, which PaymentSlips to fetch.
     * 
    **/
    where?: PaymentSlipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentSlips to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentSlipsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentSlips.
     * 
    **/
    cursor?: PaymentSlipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentSlips from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentSlips.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentSlipsScalarFieldEnum>
  }


  /**
   * PaymentSlips create
   */
  export type PaymentSlipsCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * The data needed to create a PaymentSlips.
     * 
    **/
    data: XOR<PaymentSlipsCreateInput, PaymentSlipsUncheckedCreateInput>
  }


  /**
   * PaymentSlips createMany
   */
  export type PaymentSlipsCreateManyArgs = {
    /**
     * The data used to create many PaymentSlips.
     * 
    **/
    data: Enumerable<PaymentSlipsCreateManyInput>
  }


  /**
   * PaymentSlips update
   */
  export type PaymentSlipsUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * The data needed to update a PaymentSlips.
     * 
    **/
    data: XOR<PaymentSlipsUpdateInput, PaymentSlipsUncheckedUpdateInput>
    /**
     * Choose, which PaymentSlips to update.
     * 
    **/
    where: PaymentSlipsWhereUniqueInput
  }


  /**
   * PaymentSlips updateMany
   */
  export type PaymentSlipsUpdateManyArgs = {
    /**
     * The data used to update PaymentSlips.
     * 
    **/
    data: XOR<PaymentSlipsUpdateManyMutationInput, PaymentSlipsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentSlips to update
     * 
    **/
    where?: PaymentSlipsWhereInput
  }


  /**
   * PaymentSlips upsert
   */
  export type PaymentSlipsUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * The filter to search for the PaymentSlips to update in case it exists.
     * 
    **/
    where: PaymentSlipsWhereUniqueInput
    /**
     * In case the PaymentSlips found by the `where` argument doesn't exist, create a new PaymentSlips with this data.
     * 
    **/
    create: XOR<PaymentSlipsCreateInput, PaymentSlipsUncheckedCreateInput>
    /**
     * In case the PaymentSlips was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentSlipsUpdateInput, PaymentSlipsUncheckedUpdateInput>
  }


  /**
   * PaymentSlips delete
   */
  export type PaymentSlipsDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
    /**
     * Filter which PaymentSlips to delete.
     * 
    **/
    where: PaymentSlipsWhereUniqueInput
  }


  /**
   * PaymentSlips deleteMany
   */
  export type PaymentSlipsDeleteManyArgs = {
    /**
     * Filter which PaymentSlips to delete
     * 
    **/
    where?: PaymentSlipsWhereInput
  }


  /**
   * PaymentSlips findRaw
   */
  export type PaymentSlipsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * PaymentSlips aggregateRaw
   */
  export type PaymentSlipsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * PaymentSlips without action
   */
  export type PaymentSlipsArgs = {
    /**
     * Select specific fields to fetch from the PaymentSlips
     * 
    **/
    select?: PaymentSlipsSelect | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    type: string | null
    addressTitle: string | null
    addressLine: string | null
    addressLine1: string | null
    addressLine2: string | null
    landmark: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    mobile: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    type: string | null
    addressTitle: string | null
    addressLine: string | null
    addressLine1: string | null
    addressLine2: string | null
    landmark: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    mobile: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    type: number
    addressTitle: number
    addressLine: number
    addressLine1: number
    addressLine2: number
    landmark: number
    city: number
    state: number
    country: number
    pincode: number
    mobile: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    type?: true
    addressTitle?: true
    addressLine?: true
    addressLine1?: true
    addressLine2?: true
    landmark?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    mobile?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    type?: true
    addressTitle?: true
    addressLine?: true
    addressLine1?: true
    addressLine2?: true
    landmark?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    mobile?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    type?: true
    addressTitle?: true
    addressLine?: true
    addressLine1?: true
    addressLine2?: true
    landmark?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    mobile?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: string
    type: string | null
    addressTitle: string | null
    addressLine: string | null
    addressLine1: string | null
    addressLine2: string | null
    landmark: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    mobile: string | null
    userId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    type?: boolean
    addressTitle?: boolean
    addressLine?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    landmark?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    mobile?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type AddressInclude = {
    user?: boolean | UserArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Find zero or more Addresses that matches the filter.
     * @param {AddressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const address = await prisma.address.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AddressFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Address.
     * @param {AddressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const address = await prisma.address.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AddressAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address findRaw
   */
  export type AddressFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Address aggregateRaw
   */
  export type AddressAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Expanses
   */


  export type AggregateExpanses = {
    _count: ExpansesCountAggregateOutputType | null
    _min: ExpansesMinAggregateOutputType | null
    _max: ExpansesMaxAggregateOutputType | null
  }

  export type ExpansesMinAggregateOutputType = {
    id: string | null
    title: string | null
    expensesType: string | null
    amount: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ExpansesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    expensesType: string | null
    amount: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ExpansesCountAggregateOutputType = {
    id: number
    title: number
    expensesType: number
    amount: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ExpansesMinAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ExpansesMaxAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ExpansesCountAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ExpansesAggregateArgs = {
    /**
     * Filter which Expanses to aggregate.
     * 
    **/
    where?: ExpansesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expanses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpansesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExpansesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expanses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expanses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expanses
    **/
    _count?: true | ExpansesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpansesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpansesMaxAggregateInputType
  }

  export type GetExpansesAggregateType<T extends ExpansesAggregateArgs> = {
        [P in keyof T & keyof AggregateExpanses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpanses[P]>
      : GetScalarType<T[P], AggregateExpanses[P]>
  }




  export type ExpansesGroupByArgs = {
    where?: ExpansesWhereInput
    orderBy?: Enumerable<ExpansesOrderByWithAggregationInput>
    by: Array<ExpansesScalarFieldEnum>
    having?: ExpansesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpansesCountAggregateInputType | true
    _min?: ExpansesMinAggregateInputType
    _max?: ExpansesMaxAggregateInputType
  }


  export type ExpansesGroupByOutputType = {
    id: string
    title: string | null
    expensesType: string | null
    amount: string | null
    userId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: ExpansesCountAggregateOutputType | null
    _min: ExpansesMinAggregateOutputType | null
    _max: ExpansesMaxAggregateOutputType | null
  }

  type GetExpansesGroupByPayload<T extends ExpansesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExpansesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpansesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpansesGroupByOutputType[P]>
            : GetScalarType<T[P], ExpansesGroupByOutputType[P]>
        }
      >
    >


  export type ExpansesSelect = {
    id?: boolean
    title?: boolean
    expensesType?: boolean
    amount?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type ExpansesInclude = {
    user?: boolean | UserArgs
  }

  export type ExpansesGetPayload<
    S extends boolean | null | undefined | ExpansesArgs,
    U = keyof S
      > = S extends true
        ? Expanses
    : S extends undefined
    ? never
    : S extends ExpansesArgs | ExpansesFindManyArgs
    ?'include' extends U
    ? Expanses  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Expanses ? Expanses[P] : never
  } 
    : Expanses
  : Expanses


  type ExpansesCountArgs = Merge<
    Omit<ExpansesFindManyArgs, 'select' | 'include'> & {
      select?: ExpansesCountAggregateInputType | true
    }
  >

  export interface ExpansesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Expanses that matches the filter.
     * @param {ExpansesFindUniqueArgs} args - Arguments to find a Expanses
     * @example
     * // Get one Expanses
     * const expanses = await prisma.expanses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpansesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExpansesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Expanses'> extends True ? CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>> : CheckSelect<T, Prisma__ExpansesClient<Expanses | null >, Prisma__ExpansesClient<ExpansesGetPayload<T> | null >>

    /**
     * Find the first Expanses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesFindFirstArgs} args - Arguments to find a Expanses
     * @example
     * // Get one Expanses
     * const expanses = await prisma.expanses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpansesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExpansesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Expanses'> extends True ? CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>> : CheckSelect<T, Prisma__ExpansesClient<Expanses | null >, Prisma__ExpansesClient<ExpansesGetPayload<T> | null >>

    /**
     * Find zero or more Expanses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expanses
     * const expanses = await prisma.expanses.findMany()
     * 
     * // Get first 10 Expanses
     * const expanses = await prisma.expanses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expansesWithIdOnly = await prisma.expanses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpansesFindManyArgs>(
      args?: SelectSubset<T, ExpansesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Expanses>>, PrismaPromise<Array<ExpansesGetPayload<T>>>>

    /**
     * Create a Expanses.
     * @param {ExpansesCreateArgs} args - Arguments to create a Expanses.
     * @example
     * // Create one Expanses
     * const Expanses = await prisma.expanses.create({
     *   data: {
     *     // ... data to create a Expanses
     *   }
     * })
     * 
    **/
    create<T extends ExpansesCreateArgs>(
      args: SelectSubset<T, ExpansesCreateArgs>
    ): CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>>

    /**
     * Create many Expanses.
     *     @param {ExpansesCreateManyArgs} args - Arguments to create many Expanses.
     *     @example
     *     // Create many Expanses
     *     const expanses = await prisma.expanses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExpansesCreateManyArgs>(
      args?: SelectSubset<T, ExpansesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Expanses.
     * @param {ExpansesDeleteArgs} args - Arguments to delete one Expanses.
     * @example
     * // Delete one Expanses
     * const Expanses = await prisma.expanses.delete({
     *   where: {
     *     // ... filter to delete one Expanses
     *   }
     * })
     * 
    **/
    delete<T extends ExpansesDeleteArgs>(
      args: SelectSubset<T, ExpansesDeleteArgs>
    ): CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>>

    /**
     * Update one Expanses.
     * @param {ExpansesUpdateArgs} args - Arguments to update one Expanses.
     * @example
     * // Update one Expanses
     * const expanses = await prisma.expanses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpansesUpdateArgs>(
      args: SelectSubset<T, ExpansesUpdateArgs>
    ): CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>>

    /**
     * Delete zero or more Expanses.
     * @param {ExpansesDeleteManyArgs} args - Arguments to filter Expanses to delete.
     * @example
     * // Delete a few Expanses
     * const { count } = await prisma.expanses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpansesDeleteManyArgs>(
      args?: SelectSubset<T, ExpansesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expanses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expanses
     * const expanses = await prisma.expanses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpansesUpdateManyArgs>(
      args: SelectSubset<T, ExpansesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Expanses.
     * @param {ExpansesUpsertArgs} args - Arguments to update or create a Expanses.
     * @example
     * // Update or create a Expanses
     * const expanses = await prisma.expanses.upsert({
     *   create: {
     *     // ... data to create a Expanses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expanses we want to update
     *   }
     * })
    **/
    upsert<T extends ExpansesUpsertArgs>(
      args: SelectSubset<T, ExpansesUpsertArgs>
    ): CheckSelect<T, Prisma__ExpansesClient<Expanses>, Prisma__ExpansesClient<ExpansesGetPayload<T>>>

    /**
     * Find zero or more Expanses that matches the filter.
     * @param {ExpansesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const expanses = await prisma.expanses.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ExpansesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Expanses.
     * @param {ExpansesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const expanses = await prisma.expanses.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ExpansesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Expanses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesCountArgs} args - Arguments to filter Expanses to count.
     * @example
     * // Count the number of Expanses
     * const count = await prisma.expanses.count({
     *   where: {
     *     // ... the filter for the Expanses we want to count
     *   }
     * })
    **/
    count<T extends ExpansesCountArgs>(
      args?: Subset<T, ExpansesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpansesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expanses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpansesAggregateArgs>(args: Subset<T, ExpansesAggregateArgs>): PrismaPromise<GetExpansesAggregateType<T>>

    /**
     * Group by Expanses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpansesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpansesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpansesGroupByArgs['orderBy'] }
        : { orderBy?: ExpansesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpansesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpansesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expanses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExpansesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Expanses findUnique
   */
  export type ExpansesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * Throw an Error if a Expanses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expanses to fetch.
     * 
    **/
    where: ExpansesWhereUniqueInput
  }


  /**
   * Expanses findFirst
   */
  export type ExpansesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * Throw an Error if a Expanses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expanses to fetch.
     * 
    **/
    where?: ExpansesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expanses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpansesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expanses.
     * 
    **/
    cursor?: ExpansesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expanses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expanses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expanses.
     * 
    **/
    distinct?: Enumerable<ExpansesScalarFieldEnum>
  }


  /**
   * Expanses findMany
   */
  export type ExpansesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * Filter, which Expanses to fetch.
     * 
    **/
    where?: ExpansesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expanses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpansesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expanses.
     * 
    **/
    cursor?: ExpansesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expanses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expanses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExpansesScalarFieldEnum>
  }


  /**
   * Expanses create
   */
  export type ExpansesCreateArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * The data needed to create a Expanses.
     * 
    **/
    data: XOR<ExpansesCreateInput, ExpansesUncheckedCreateInput>
  }


  /**
   * Expanses createMany
   */
  export type ExpansesCreateManyArgs = {
    /**
     * The data used to create many Expanses.
     * 
    **/
    data: Enumerable<ExpansesCreateManyInput>
  }


  /**
   * Expanses update
   */
  export type ExpansesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * The data needed to update a Expanses.
     * 
    **/
    data: XOR<ExpansesUpdateInput, ExpansesUncheckedUpdateInput>
    /**
     * Choose, which Expanses to update.
     * 
    **/
    where: ExpansesWhereUniqueInput
  }


  /**
   * Expanses updateMany
   */
  export type ExpansesUpdateManyArgs = {
    /**
     * The data used to update Expanses.
     * 
    **/
    data: XOR<ExpansesUpdateManyMutationInput, ExpansesUncheckedUpdateManyInput>
    /**
     * Filter which Expanses to update
     * 
    **/
    where?: ExpansesWhereInput
  }


  /**
   * Expanses upsert
   */
  export type ExpansesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * The filter to search for the Expanses to update in case it exists.
     * 
    **/
    where: ExpansesWhereUniqueInput
    /**
     * In case the Expanses found by the `where` argument doesn't exist, create a new Expanses with this data.
     * 
    **/
    create: XOR<ExpansesCreateInput, ExpansesUncheckedCreateInput>
    /**
     * In case the Expanses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExpansesUpdateInput, ExpansesUncheckedUpdateInput>
  }


  /**
   * Expanses delete
   */
  export type ExpansesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
    /**
     * Filter which Expanses to delete.
     * 
    **/
    where: ExpansesWhereUniqueInput
  }


  /**
   * Expanses deleteMany
   */
  export type ExpansesDeleteManyArgs = {
    /**
     * Filter which Expanses to delete
     * 
    **/
    where?: ExpansesWhereInput
  }


  /**
   * Expanses findRaw
   */
  export type ExpansesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Expanses aggregateRaw
   */
  export type ExpansesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Expanses without action
   */
  export type ExpansesArgs = {
    /**
     * Select specific fields to fetch from the Expanses
     * 
    **/
    select?: ExpansesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpansesInclude | null
  }



  /**
   * Model Employee
   */


  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    title: string | null
    departmentId: string | null
    monthlyPay: string | null
    yearlyPay: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    departmentId: string | null
    monthlyPay: string | null
    yearlyPay: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    title: number
    departmentId: number
    monthlyPay: number
    yearlyPay: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    monthlyPay?: true
    yearlyPay?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    monthlyPay?: true
    yearlyPay?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    title?: true
    departmentId?: true
    monthlyPay?: true
    yearlyPay?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type EmployeeAggregateArgs = {
    /**
     * Filter which Employee to aggregate.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs = {
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByWithAggregationInput>
    by: Array<EmployeeScalarFieldEnum>
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }


  export type EmployeeGroupByOutputType = {
    id: string
    title: string | null
    departmentId: string
    monthlyPay: string | null
    yearlyPay: string | null
    userId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect = {
    id?: boolean
    title?: boolean
    department?: boolean | DepartmentArgs
    departmentId?: boolean
    monthlyPay?: boolean
    yearlyPay?: boolean
    salary?: boolean | SalaryFindManyArgs
    user?: boolean | UserArgs
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    Attendance?: boolean | AttendanceFindManyArgs
    _count?: boolean | EmployeeCountOutputTypeArgs
  }

  export type EmployeeInclude = {
    department?: boolean | DepartmentArgs
    salary?: boolean | SalaryFindManyArgs
    user?: boolean | UserArgs
    Attendance?: boolean | AttendanceFindManyArgs
    _count?: boolean | EmployeeCountOutputTypeArgs
  }

  export type EmployeeGetPayload<
    S extends boolean | null | undefined | EmployeeArgs,
    U = keyof S
      > = S extends true
        ? Employee
    : S extends undefined
    ? never
    : S extends EmployeeArgs | EmployeeFindManyArgs
    ?'include' extends U
    ? Employee  & {
    [P in TrueKeys<S['include']>]:
        P extends 'department' ? DepartmentGetPayload<S['include'][P]> :
        P extends 'salary' ? Array < SalaryGetPayload<S['include'][P]>>  :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'Attendance' ? Array < AttendanceGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmployeeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'department' ? DepartmentGetPayload<S['select'][P]> :
        P extends 'salary' ? Array < SalaryGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'Attendance' ? Array < AttendanceGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmployeeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Employee ? Employee[P] : never
  } 
    : Employee
  : Employee


  type EmployeeCountArgs = Merge<
    Omit<EmployeeFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeCountAggregateInputType | true
    }
  >

  export interface EmployeeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmployeeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmployeeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeFindManyArgs>(
      args?: SelectSubset<T, EmployeeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
    **/
    create<T extends EmployeeCreateArgs>(
      args: SelectSubset<T, EmployeeCreateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Create many Employees.
     *     @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     *     @example
     *     // Create many Employees
     *     const employee = await prisma.employee.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeCreateManyArgs>(
      args?: SelectSubset<T, EmployeeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeDeleteArgs>(
      args: SelectSubset<T, EmployeeDeleteArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeUpdateArgs>(
      args: SelectSubset<T, EmployeeUpdateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeDeleteManyArgs>(
      args?: SelectSubset<T, EmployeeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeUpdateManyArgs>(
      args: SelectSubset<T, EmployeeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeUpsertArgs>(
      args: SelectSubset<T, EmployeeUpsertArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Find zero or more Employees that matches the filter.
     * @param {EmployeeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const employee = await prisma.employee.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EmployeeFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Employee.
     * @param {EmployeeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const employee = await prisma.employee.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EmployeeAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    department<T extends DepartmentArgs = {}>(args?: Subset<T, DepartmentArgs>): CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>;

    salary<T extends SalaryFindManyArgs = {}>(args?: Subset<T, SalaryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Salary>>, PrismaPromise<Array<SalaryGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Attendance<T extends AttendanceFindManyArgs = {}>(args?: Subset<T, AttendanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Attendance>>, PrismaPromise<Array<AttendanceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     * 
    **/
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter, which Employees to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee create
   */
  export type EmployeeCreateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to create a Employee.
     * 
    **/
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }


  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs = {
    /**
     * The data used to create many Employees.
     * 
    **/
    data: Enumerable<EmployeeCreateManyInput>
  }


  /**
   * Employee update
   */
  export type EmployeeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to update a Employee.
     * 
    **/
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs = {
    /**
     * The data used to update Employees.
     * 
    **/
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     * 
    **/
    where?: EmployeeWhereInput
  }


  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The filter to search for the Employee to update in case it exists.
     * 
    **/
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     * 
    **/
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }


  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter which Employee to delete.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs = {
    /**
     * Filter which Employees to delete
     * 
    **/
    where?: EmployeeWhereInput
  }


  /**
   * Employee findRaw
   */
  export type EmployeeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Employee aggregateRaw
   */
  export type EmployeeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Employee without action
   */
  export type EmployeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
  }



  /**
   * Model Department
   */


  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    title: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    title?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type DepartmentAggregateArgs = {
    /**
     * Filter which Department to aggregate.
     * 
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs = {
    where?: DepartmentWhereInput
    orderBy?: Enumerable<DepartmentOrderByWithAggregationInput>
    by: Array<DepartmentScalarFieldEnum>
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }


  export type DepartmentGroupByOutputType = {
    id: string
    title: string | null
    userId: string
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect = {
    id?: boolean
    title?: boolean
    employees?: boolean | EmployeeFindManyArgs
    user?: boolean | UserArgs
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | DepartmentCountOutputTypeArgs
  }

  export type DepartmentInclude = {
    employees?: boolean | EmployeeFindManyArgs
    user?: boolean | UserArgs
    _count?: boolean | DepartmentCountOutputTypeArgs
  }

  export type DepartmentGetPayload<
    S extends boolean | null | undefined | DepartmentArgs,
    U = keyof S
      > = S extends true
        ? Department
    : S extends undefined
    ? never
    : S extends DepartmentArgs | DepartmentFindManyArgs
    ?'include' extends U
    ? Department  & {
    [P in TrueKeys<S['include']>]:
        P extends 'employees' ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends '_count' ? DepartmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'employees' ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends '_count' ? DepartmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Department ? Department[P] : never
  } 
    : Department
  : Department


  type DepartmentCountArgs = Merge<
    Omit<DepartmentFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentCountAggregateInputType | true
    }
  >

  export interface DepartmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DepartmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Department'> extends True ? CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>> : CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DepartmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Department'> extends True ? CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>> : CheckSelect<T, Prisma__DepartmentClient<Department | null >, Prisma__DepartmentClient<DepartmentGetPayload<T> | null >>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DepartmentFindManyArgs>(
      args?: SelectSubset<T, DepartmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Department>>, PrismaPromise<Array<DepartmentGetPayload<T>>>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
    **/
    create<T extends DepartmentCreateArgs>(
      args: SelectSubset<T, DepartmentCreateArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Create many Departments.
     *     @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     *     @example
     *     // Create many Departments
     *     const department = await prisma.department.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepartmentCreateManyArgs>(
      args?: SelectSubset<T, DepartmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
    **/
    delete<T extends DepartmentDeleteArgs>(
      args: SelectSubset<T, DepartmentDeleteArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartmentUpdateArgs>(
      args: SelectSubset<T, DepartmentUpdateArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartmentDeleteManyArgs>(
      args?: SelectSubset<T, DepartmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartmentUpdateManyArgs>(
      args: SelectSubset<T, DepartmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
    **/
    upsert<T extends DepartmentUpsertArgs>(
      args: SelectSubset<T, DepartmentUpsertArgs>
    ): CheckSelect<T, Prisma__DepartmentClient<Department>, Prisma__DepartmentClient<DepartmentGetPayload<T>>>

    /**
     * Find zero or more Departments that matches the filter.
     * @param {DepartmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const department = await prisma.department.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DepartmentFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Department.
     * @param {DepartmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const department = await prisma.department.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DepartmentAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DepartmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employees<T extends EmployeeFindManyArgs = {}>(args?: Subset<T, EmployeeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * Throw an Error if a Department can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Department to fetch.
     * 
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * Throw an Error if a Department can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Department to fetch.
     * 
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     * 
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     * 
    **/
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * Filter, which Departments to fetch.
     * 
    **/
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     * 
    **/
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     * 
    **/
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department create
   */
  export type DepartmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * The data needed to create a Department.
     * 
    **/
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }


  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs = {
    /**
     * The data used to create many Departments.
     * 
    **/
    data: Enumerable<DepartmentCreateManyInput>
  }


  /**
   * Department update
   */
  export type DepartmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * The data needed to update a Department.
     * 
    **/
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     * 
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs = {
    /**
     * The data used to update Departments.
     * 
    **/
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     * 
    **/
    where?: DepartmentWhereInput
  }


  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * The filter to search for the Department to update in case it exists.
     * 
    **/
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     * 
    **/
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }


  /**
   * Department delete
   */
  export type DepartmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
    /**
     * Filter which Department to delete.
     * 
    **/
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs = {
    /**
     * Filter which Departments to delete
     * 
    **/
    where?: DepartmentWhereInput
  }


  /**
   * Department findRaw
   */
  export type DepartmentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Department aggregateRaw
   */
  export type DepartmentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Department without action
   */
  export type DepartmentArgs = {
    /**
     * Select specific fields to fetch from the Department
     * 
    **/
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DepartmentInclude | null
  }



  /**
   * Model Attendance
   */


  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    title: string | null
    from: string | null
    to: string | null
    presents: string | null
    absents: string | null
    paidLeaves: string | null
    salaryId: string | null
    employeeId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    from: string | null
    to: string | null
    presents: string | null
    absents: string | null
    paidLeaves: string | null
    salaryId: string | null
    employeeId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    title: number
    from: number
    to: number
    presents: number
    absents: number
    paidLeaves: number
    salaryId: number
    employeeId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    title?: true
    from?: true
    to?: true
    presents?: true
    absents?: true
    paidLeaves?: true
    salaryId?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    title?: true
    from?: true
    to?: true
    presents?: true
    absents?: true
    paidLeaves?: true
    salaryId?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    title?: true
    from?: true
    to?: true
    presents?: true
    absents?: true
    paidLeaves?: true
    salaryId?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AttendanceAggregateArgs = {
    /**
     * Filter which Attendance to aggregate.
     * 
    **/
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs = {
    where?: AttendanceWhereInput
    orderBy?: Enumerable<AttendanceOrderByWithAggregationInput>
    by: Array<AttendanceScalarFieldEnum>
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }


  export type AttendanceGroupByOutputType = {
    id: string
    title: string | null
    from: string | null
    to: string | null
    presents: string | null
    absents: string | null
    paidLeaves: string | null
    salaryId: string | null
    employeeId: string | null
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect = {
    id?: boolean
    title?: boolean
    from?: boolean
    to?: boolean
    presents?: boolean
    absents?: boolean
    paidLeaves?: boolean
    Salary?: boolean | SalaryArgs
    salaryId?: boolean
    Employee?: boolean | EmployeeArgs
    employeeId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type AttendanceInclude = {
    Salary?: boolean | SalaryArgs
    Employee?: boolean | EmployeeArgs
  }

  export type AttendanceGetPayload<
    S extends boolean | null | undefined | AttendanceArgs,
    U = keyof S
      > = S extends true
        ? Attendance
    : S extends undefined
    ? never
    : S extends AttendanceArgs | AttendanceFindManyArgs
    ?'include' extends U
    ? Attendance  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Salary' ? SalaryGetPayload<S['include'][P]> | null :
        P extends 'Employee' ? EmployeeGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Salary' ? SalaryGetPayload<S['select'][P]> | null :
        P extends 'Employee' ? EmployeeGetPayload<S['select'][P]> | null :  P extends keyof Attendance ? Attendance[P] : never
  } 
    : Attendance
  : Attendance


  type AttendanceCountArgs = Merge<
    Omit<AttendanceFindManyArgs, 'select' | 'include'> & {
      select?: AttendanceCountAggregateInputType | true
    }
  >

  export interface AttendanceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttendanceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttendanceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Attendance'> extends True ? CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>> : CheckSelect<T, Prisma__AttendanceClient<Attendance | null >, Prisma__AttendanceClient<AttendanceGetPayload<T> | null >>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttendanceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttendanceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Attendance'> extends True ? CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>> : CheckSelect<T, Prisma__AttendanceClient<Attendance | null >, Prisma__AttendanceClient<AttendanceGetPayload<T> | null >>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttendanceFindManyArgs>(
      args?: SelectSubset<T, AttendanceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Attendance>>, PrismaPromise<Array<AttendanceGetPayload<T>>>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
    **/
    create<T extends AttendanceCreateArgs>(
      args: SelectSubset<T, AttendanceCreateArgs>
    ): CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>>

    /**
     * Create many Attendances.
     *     @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     *     @example
     *     // Create many Attendances
     *     const attendance = await prisma.attendance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttendanceCreateManyArgs>(
      args?: SelectSubset<T, AttendanceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
    **/
    delete<T extends AttendanceDeleteArgs>(
      args: SelectSubset<T, AttendanceDeleteArgs>
    ): CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttendanceUpdateArgs>(
      args: SelectSubset<T, AttendanceUpdateArgs>
    ): CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttendanceDeleteManyArgs>(
      args?: SelectSubset<T, AttendanceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttendanceUpdateManyArgs>(
      args: SelectSubset<T, AttendanceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
    **/
    upsert<T extends AttendanceUpsertArgs>(
      args: SelectSubset<T, AttendanceUpsertArgs>
    ): CheckSelect<T, Prisma__AttendanceClient<Attendance>, Prisma__AttendanceClient<AttendanceGetPayload<T>>>

    /**
     * Find zero or more Attendances that matches the filter.
     * @param {AttendanceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendance = await prisma.attendance.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AttendanceFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendance.
     * @param {AttendanceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendance = await prisma.attendance.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AttendanceAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttendanceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Salary<T extends SalaryArgs = {}>(args?: Subset<T, SalaryArgs>): CheckSelect<T, Prisma__SalaryClient<Salary | null >, Prisma__SalaryClient<SalaryGetPayload<T> | null >>;

    Employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * Throw an Error if a Attendance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attendance to fetch.
     * 
    **/
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * Throw an Error if a Attendance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attendance to fetch.
     * 
    **/
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     * 
    **/
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     * 
    **/
    distinct?: Enumerable<AttendanceScalarFieldEnum>
  }


  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * Filter, which Attendances to fetch.
     * 
    **/
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     * 
    **/
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AttendanceScalarFieldEnum>
  }


  /**
   * Attendance create
   */
  export type AttendanceCreateArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * The data needed to create a Attendance.
     * 
    **/
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }


  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs = {
    /**
     * The data used to create many Attendances.
     * 
    **/
    data: Enumerable<AttendanceCreateManyInput>
  }


  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * The data needed to update a Attendance.
     * 
    **/
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     * 
    **/
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs = {
    /**
     * The data used to update Attendances.
     * 
    **/
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     * 
    **/
    where?: AttendanceWhereInput
  }


  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     * 
    **/
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     * 
    **/
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }


  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
    /**
     * Filter which Attendance to delete.
     * 
    **/
    where: AttendanceWhereUniqueInput
  }


  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs = {
    /**
     * Filter which Attendances to delete
     * 
    **/
    where?: AttendanceWhereInput
  }


  /**
   * Attendance findRaw
   */
  export type AttendanceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Attendance aggregateRaw
   */
  export type AttendanceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Attendance without action
   */
  export type AttendanceArgs = {
    /**
     * Select specific fields to fetch from the Attendance
     * 
    **/
    select?: AttendanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendanceInclude | null
  }



  /**
   * Model Salary
   */


  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryMinAggregateOutputType = {
    id: string | null
    title: string | null
    expensesType: string | null
    amount: string | null
    from: string | null
    to: string | null
    employeeId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    expensesType: string | null
    amount: string | null
    from: string | null
    to: string | null
    employeeId: string | null
    userId: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    title: number
    expensesType: number
    amount: number
    from: number
    to: number
    employeeId: number
    userId: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type SalaryMinAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    from?: true
    to?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    from?: true
    to?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    title?: true
    expensesType?: true
    amount?: true
    from?: true
    to?: true
    employeeId?: true
    userId?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type SalaryAggregateArgs = {
    /**
     * Filter which Salary to aggregate.
     * 
    **/
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     * 
    **/
    orderBy?: Enumerable<SalaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type SalaryGroupByArgs = {
    where?: SalaryWhereInput
    orderBy?: Enumerable<SalaryOrderByWithAggregationInput>
    by: Array<SalaryScalarFieldEnum>
    having?: SalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }


  export type SalaryGroupByOutputType = {
    id: string
    title: string | null
    expensesType: string | null
    amount: string | null
    from: string | null
    to: string | null
    employeeId: string
    userId: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date
    _count: SalaryCountAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends SalaryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type SalarySelect = {
    id?: boolean
    title?: boolean
    expensesType?: boolean
    amount?: boolean
    from?: boolean
    to?: boolean
    attendance?: boolean | AttendanceFindManyArgs
    employee?: boolean | EmployeeArgs
    employeeId?: boolean
    userId?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    _count?: boolean | SalaryCountOutputTypeArgs
  }

  export type SalaryInclude = {
    attendance?: boolean | AttendanceFindManyArgs
    employee?: boolean | EmployeeArgs
    _count?: boolean | SalaryCountOutputTypeArgs
  }

  export type SalaryGetPayload<
    S extends boolean | null | undefined | SalaryArgs,
    U = keyof S
      > = S extends true
        ? Salary
    : S extends undefined
    ? never
    : S extends SalaryArgs | SalaryFindManyArgs
    ?'include' extends U
    ? Salary  & {
    [P in TrueKeys<S['include']>]:
        P extends 'attendance' ? Array < AttendanceGetPayload<S['include'][P]>>  :
        P extends 'employee' ? EmployeeGetPayload<S['include'][P]> :
        P extends '_count' ? SalaryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'attendance' ? Array < AttendanceGetPayload<S['select'][P]>>  :
        P extends 'employee' ? EmployeeGetPayload<S['select'][P]> :
        P extends '_count' ? SalaryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Salary ? Salary[P] : never
  } 
    : Salary
  : Salary


  type SalaryCountArgs = Merge<
    Omit<SalaryFindManyArgs, 'select' | 'include'> & {
      select?: SalaryCountAggregateInputType | true
    }
  >

  export interface SalaryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Salary that matches the filter.
     * @param {SalaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalaryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalaryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Salary'> extends True ? CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>> : CheckSelect<T, Prisma__SalaryClient<Salary | null >, Prisma__SalaryClient<SalaryGetPayload<T> | null >>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalaryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalaryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Salary'> extends True ? CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>> : CheckSelect<T, Prisma__SalaryClient<Salary | null >, Prisma__SalaryClient<SalaryGetPayload<T> | null >>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalaryFindManyArgs>(
      args?: SelectSubset<T, SalaryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Salary>>, PrismaPromise<Array<SalaryGetPayload<T>>>>

    /**
     * Create a Salary.
     * @param {SalaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
    **/
    create<T extends SalaryCreateArgs>(
      args: SelectSubset<T, SalaryCreateArgs>
    ): CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>>

    /**
     * Create many Salaries.
     *     @param {SalaryCreateManyArgs} args - Arguments to create many Salaries.
     *     @example
     *     // Create many Salaries
     *     const salary = await prisma.salary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalaryCreateManyArgs>(
      args?: SelectSubset<T, SalaryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Salary.
     * @param {SalaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
    **/
    delete<T extends SalaryDeleteArgs>(
      args: SelectSubset<T, SalaryDeleteArgs>
    ): CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>>

    /**
     * Update one Salary.
     * @param {SalaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalaryUpdateArgs>(
      args: SelectSubset<T, SalaryUpdateArgs>
    ): CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>>

    /**
     * Delete zero or more Salaries.
     * @param {SalaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalaryDeleteManyArgs>(
      args?: SelectSubset<T, SalaryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalaryUpdateManyArgs>(
      args: SelectSubset<T, SalaryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Salary.
     * @param {SalaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
    **/
    upsert<T extends SalaryUpsertArgs>(
      args: SelectSubset<T, SalaryUpsertArgs>
    ): CheckSelect<T, Prisma__SalaryClient<Salary>, Prisma__SalaryClient<SalaryGetPayload<T>>>

    /**
     * Find zero or more Salaries that matches the filter.
     * @param {SalaryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const salary = await prisma.salary.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SalaryFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Salary.
     * @param {SalaryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const salary = await prisma.salary.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SalaryAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalaryCountArgs>(
      args?: Subset<T, SalaryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryGroupByArgs['orderBy'] }
        : { orderBy?: SalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalaryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    attendance<T extends AttendanceFindManyArgs = {}>(args?: Subset<T, AttendanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Attendance>>, PrismaPromise<Array<AttendanceGetPayload<T>>>>;

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Salary findUnique
   */
  export type SalaryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * Throw an Error if a Salary can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salary to fetch.
     * 
    **/
    where: SalaryWhereUniqueInput
  }


  /**
   * Salary findFirst
   */
  export type SalaryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * Throw an Error if a Salary can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salary to fetch.
     * 
    **/
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     * 
    **/
    orderBy?: Enumerable<SalaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     * 
    **/
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     * 
    **/
    distinct?: Enumerable<SalaryScalarFieldEnum>
  }


  /**
   * Salary findMany
   */
  export type SalaryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * Filter, which Salaries to fetch.
     * 
    **/
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     * 
    **/
    orderBy?: Enumerable<SalaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     * 
    **/
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SalaryScalarFieldEnum>
  }


  /**
   * Salary create
   */
  export type SalaryCreateArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * The data needed to create a Salary.
     * 
    **/
    data: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
  }


  /**
   * Salary createMany
   */
  export type SalaryCreateManyArgs = {
    /**
     * The data used to create many Salaries.
     * 
    **/
    data: Enumerable<SalaryCreateManyInput>
  }


  /**
   * Salary update
   */
  export type SalaryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * The data needed to update a Salary.
     * 
    **/
    data: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
    /**
     * Choose, which Salary to update.
     * 
    **/
    where: SalaryWhereUniqueInput
  }


  /**
   * Salary updateMany
   */
  export type SalaryUpdateManyArgs = {
    /**
     * The data used to update Salaries.
     * 
    **/
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     * 
    **/
    where?: SalaryWhereInput
  }


  /**
   * Salary upsert
   */
  export type SalaryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * The filter to search for the Salary to update in case it exists.
     * 
    **/
    where: SalaryWhereUniqueInput
    /**
     * In case the Salary found by the `where` argument doesn't exist, create a new Salary with this data.
     * 
    **/
    create: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
    /**
     * In case the Salary was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
  }


  /**
   * Salary delete
   */
  export type SalaryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
    /**
     * Filter which Salary to delete.
     * 
    **/
    where: SalaryWhereUniqueInput
  }


  /**
   * Salary deleteMany
   */
  export type SalaryDeleteManyArgs = {
    /**
     * Filter which Salaries to delete
     * 
    **/
    where?: SalaryWhereInput
  }


  /**
   * Salary findRaw
   */
  export type SalaryFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Salary aggregateRaw
   */
  export type SalaryAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Salary without action
   */
  export type SalaryArgs = {
    /**
     * Select specific fields to fetch from the Salary
     * 
    **/
    select?: SalarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalaryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const PermissionsScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    actions: 'actions',
    parents: 'parents',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    userId: 'userId'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    mobile: 'mobile',
    roleId: 'roleId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    staff: 'staff',
    addressId: 'addressId',
    incharge: 'incharge',
    userId: 'userId'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const RacksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    length: 'length',
    width: 'width',
    height: 'height',
    side: 'side',
    userId: 'userId',
    warehouseId: 'warehouseId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type RacksScalarFieldEnum = (typeof RacksScalarFieldEnum)[keyof typeof RacksScalarFieldEnum]


  export const ShelfScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    length: 'length',
    width: 'width',
    height: 'height',
    side: 'side',
    totalSpace: 'totalSpace',
    availableSpace: 'availableSpace',
    rackId: 'rackId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ShelfScalarFieldEnum = (typeof ShelfScalarFieldEnum)[keyof typeof ShelfScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    title: 'title',
    short_desc: 'short_desc',
    desc: 'desc',
    bulletPoints: 'bulletPoints',
    categories: 'categories',
    variation: 'variation',
    images: 'images',
    price: 'price',
    quantity: 'quantity',
    purchase_price: 'purchase_price',
    userId: 'userId',
    warehouseId: 'warehouseId',
    shelfId: 'shelfId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const POScalarFieldEnum: {
    id: 'id',
    poStatus: 'poStatus',
    paymentStatus: 'paymentStatus',
    paindAmount: 'paindAmount',
    pendingAmount: 'pendingAmount',
    totalPrice: 'totalPrice',
    totalTax: 'totalTax',
    totalDiscount: 'totalDiscount',
    totalTransportation: 'totalTransportation',
    totalExpenses: 'totalExpenses',
    userId: 'userId',
    vendorId: 'vendorId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type POScalarFieldEnum = (typeof POScalarFieldEnum)[keyof typeof POScalarFieldEnum]


  export const POItemsScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    title: 'title',
    short_desc: 'short_desc',
    desc: 'desc',
    categories: 'categories',
    variation: 'variation',
    images: 'images',
    price: 'price',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    quantity: 'quantity',
    poId: 'poId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type POItemsScalarFieldEnum = (typeof POItemsScalarFieldEnum)[keyof typeof POItemsScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceStatus: 'invoiceStatus',
    paymentStatus: 'paymentStatus',
    paindAmount: 'paindAmount',
    pendingAmount: 'pendingAmount',
    totalPrice: 'totalPrice',
    totalTax: 'totalTax',
    totalDiscount: 'totalDiscount',
    totalTransportation: 'totalTransportation',
    totalExpenses: 'totalExpenses',
    buyerId: 'buyerId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemsScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    title: 'title',
    short_desc: 'short_desc',
    desc: 'desc',
    categories: 'categories',
    variation: 'variation',
    images: 'images',
    price: 'price',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    quantity: 'quantity',
    invoiceId: 'invoiceId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type InvoiceItemsScalarFieldEnum = (typeof InvoiceItemsScalarFieldEnum)[keyof typeof InvoiceItemsScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderStatus: 'orderStatus',
    paymentStatus: 'paymentStatus',
    paindAmount: 'paindAmount',
    pendingAmount: 'pendingAmount',
    totalPrice: 'totalPrice',
    totalTax: 'totalTax',
    totalDiscount: 'totalDiscount',
    totalTransportation: 'totalTransportation',
    totalExpenses: 'totalExpenses',
    buyerId: 'buyerId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemsScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    title: 'title',
    short_desc: 'short_desc',
    desc: 'desc',
    categories: 'categories',
    variation: 'variation',
    images: 'images',
    price: 'price',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    quantity: 'quantity',
    orderId: 'orderId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type OrderItemsScalarFieldEnum = (typeof OrderItemsScalarFieldEnum)[keyof typeof OrderItemsScalarFieldEnum]


  export const PaymentSlipsScalarFieldEnum: {
    id: 'id',
    paymentType: 'paymentType',
    paymentTypeId: 'paymentTypeId',
    paidAmount: 'paidAmount',
    paymentMode: 'paymentMode',
    paymentStatus: 'paymentStatus',
    paidBy: 'paidBy',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type PaymentSlipsScalarFieldEnum = (typeof PaymentSlipsScalarFieldEnum)[keyof typeof PaymentSlipsScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    type: 'type',
    addressTitle: 'addressTitle',
    addressLine: 'addressLine',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    landmark: 'landmark',
    city: 'city',
    state: 'state',
    country: 'country',
    pincode: 'pincode',
    mobile: 'mobile',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ExpansesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    expensesType: 'expensesType',
    amount: 'amount',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ExpansesScalarFieldEnum = (typeof ExpansesScalarFieldEnum)[keyof typeof ExpansesScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    departmentId: 'departmentId',
    monthlyPay: 'monthlyPay',
    yearlyPay: 'yearlyPay',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    from: 'from',
    to: 'to',
    presents: 'presents',
    absents: 'absents',
    paidLeaves: 'paidLeaves',
    salaryId: 'salaryId',
    employeeId: 'employeeId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    expensesType: 'expensesType',
    amount: 'amount',
    from: 'from',
    to: 'to',
    employeeId: 'employeeId',
    userId: 'userId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type PermissionsWhereInput = {
    AND?: Enumerable<PermissionsWhereInput>
    OR?: Enumerable<PermissionsWhereInput>
    NOT?: Enumerable<PermissionsWhereInput>
    id?: StringFilter | string
    slug?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    actions?: StringNullableListFilter
    parents?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    RolePermission?: RolePermissionListRelationFilter
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    actions?: SortOrder
    parents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
    RolePermission?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionsWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    actions?: SortOrder
    parents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    userId?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    slug?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    actions?: StringNullableListFilter
    parents?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    address?: AddressListRelationFilter
    permission?: PermissionsListRelationFilter
    expenses?: ExpansesListRelationFilter
    employees?: EmployeeListRelationFilter
    departments?: DepartmentListRelationFilter
    roleId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    permission?: PermissionsOrderByRelationAggregateInput
    expenses?: ExpansesOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    roleId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringNullableWithAggregatesFilter | string | null
    roleId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: Enumerable<WarehouseWhereInput>
    OR?: Enumerable<WarehouseWhereInput>
    NOT?: Enumerable<WarehouseWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    staff?: StringNullableFilter | string | null
    addressId?: StringNullableListFilter
    incharge?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    products?: ProductListRelationFilter
    racks?: RacksListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    staff?: SortOrder
    addressId?: SortOrder
    incharge?: SortOrder
    userId?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    racks?: RacksOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = {
    id?: string
  }

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    staff?: SortOrder
    addressId?: SortOrder
    incharge?: SortOrder
    userId?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WarehouseScalarWhereWithAggregatesInput>
    OR?: Enumerable<WarehouseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WarehouseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    staff?: StringNullableWithAggregatesFilter | string | null
    addressId?: StringNullableListFilter
    incharge?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type RacksWhereInput = {
    AND?: Enumerable<RacksWhereInput>
    OR?: Enumerable<RacksWhereInput>
    NOT?: Enumerable<RacksWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    side?: StringNullableFilter | string | null
    shelf?: ShelfListRelationFilter
    userId?: StringNullableFilter | string | null
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    warehouseId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type RacksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    shelf?: ShelfOrderByRelationAggregateInput
    userId?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    warehouseId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RacksWhereUniqueInput = {
    id?: string
  }

  export type RacksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: RacksCountOrderByAggregateInput
    _max?: RacksMaxOrderByAggregateInput
    _min?: RacksMinOrderByAggregateInput
  }

  export type RacksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RacksScalarWhereWithAggregatesInput>
    OR?: Enumerable<RacksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RacksScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    code?: StringNullableWithAggregatesFilter | string | null
    length?: StringNullableWithAggregatesFilter | string | null
    width?: StringNullableWithAggregatesFilter | string | null
    height?: StringNullableWithAggregatesFilter | string | null
    side?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    warehouseId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ShelfWhereInput = {
    AND?: Enumerable<ShelfWhereInput>
    OR?: Enumerable<ShelfWhereInput>
    NOT?: Enumerable<ShelfWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    side?: StringNullableFilter | string | null
    totalSpace?: StringNullableFilter | string | null
    availableSpace?: StringNullableFilter | string | null
    Product?: ProductListRelationFilter
    racks?: XOR<RacksRelationFilter, RacksWhereInput>
    rackId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type ShelfOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    totalSpace?: SortOrder
    availableSpace?: SortOrder
    Product?: ProductOrderByRelationAggregateInput
    racks?: RacksOrderByWithRelationInput
    rackId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ShelfWhereUniqueInput = {
    id?: string
  }

  export type ShelfOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    totalSpace?: SortOrder
    availableSpace?: SortOrder
    rackId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: ShelfCountOrderByAggregateInput
    _max?: ShelfMaxOrderByAggregateInput
    _min?: ShelfMinOrderByAggregateInput
  }

  export type ShelfScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShelfScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShelfScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShelfScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    code?: StringNullableWithAggregatesFilter | string | null
    length?: StringNullableWithAggregatesFilter | string | null
    width?: StringNullableWithAggregatesFilter | string | null
    height?: StringNullableWithAggregatesFilter | string | null
    side?: StringNullableWithAggregatesFilter | string | null
    totalSpace?: StringNullableWithAggregatesFilter | string | null
    availableSpace?: StringNullableWithAggregatesFilter | string | null
    rackId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    bulletPoints?: StringNullableListFilter
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    quantity?: StringNullableListFilter
    purchase_price?: StringNullableListFilter
    userId?: StringNullableFilter | string | null
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    warehouseId?: StringFilter | string
    shelf?: XOR<ShelfRelationFilter, ShelfWhereInput>
    shelfId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    bulletPoints?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    purchase_price?: SortOrder
    userId?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    warehouseId?: SortOrder
    shelf?: ShelfOrderByWithRelationInput
    shelfId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: string
    sku?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    bulletPoints?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    purchase_price?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    shelfId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sku?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    short_desc?: StringNullableWithAggregatesFilter | string | null
    desc?: StringNullableWithAggregatesFilter | string | null
    bulletPoints?: StringNullableListFilter
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    quantity?: StringNullableListFilter
    purchase_price?: StringNullableListFilter
    userId?: StringNullableWithAggregatesFilter | string | null
    warehouseId?: StringWithAggregatesFilter | string
    shelfId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleWhereUniqueInput = {
    id?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: Enumerable<RolePermissionWhereInput>
    OR?: Enumerable<RolePermissionWhereInput>
    NOT?: Enumerable<RolePermissionWhereInput>
    id?: StringFilter | string
    roleId?: StringNullableFilter | string | null
    permission?: XOR<PermissionsRelationFilter, PermissionsWhereInput>
    permissionId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permission?: PermissionsOrderByWithRelationInput
    permissionId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RolePermissionWhereUniqueInput = {
    id?: string
  }

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolePermissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    roleId?: StringNullableWithAggregatesFilter | string | null
    permissionId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type POWhereInput = {
    AND?: Enumerable<POWhereInput>
    OR?: Enumerable<POWhereInput>
    NOT?: Enumerable<POWhereInput>
    id?: StringFilter | string
    poStatus?: StringNullableFilter | string | null
    paymentStatus?: StringNullableFilter | string | null
    paindAmount?: StringNullableFilter | string | null
    pendingAmount?: StringNullableFilter | string | null
    totalPrice?: StringNullableFilter | string | null
    totalTax?: StringNullableFilter | string | null
    totalDiscount?: StringNullableFilter | string | null
    totalTransportation?: StringNullableFilter | string | null
    totalExpenses?: StringNullableFilter | string | null
    poItem?: POItemsListRelationFilter
    userId?: StringNullableFilter | string | null
    vendorId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type POOrderByWithRelationInput = {
    id?: SortOrder
    poStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    poItem?: POItemsOrderByRelationAggregateInput
    userId?: SortOrder
    vendorId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POWhereUniqueInput = {
    id?: string
  }

  export type POOrderByWithAggregationInput = {
    id?: SortOrder
    poStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: POCountOrderByAggregateInput
    _max?: POMaxOrderByAggregateInput
    _min?: POMinOrderByAggregateInput
  }

  export type POScalarWhereWithAggregatesInput = {
    AND?: Enumerable<POScalarWhereWithAggregatesInput>
    OR?: Enumerable<POScalarWhereWithAggregatesInput>
    NOT?: Enumerable<POScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    poStatus?: StringNullableWithAggregatesFilter | string | null
    paymentStatus?: StringNullableWithAggregatesFilter | string | null
    paindAmount?: StringNullableWithAggregatesFilter | string | null
    pendingAmount?: StringNullableWithAggregatesFilter | string | null
    totalPrice?: StringNullableWithAggregatesFilter | string | null
    totalTax?: StringNullableWithAggregatesFilter | string | null
    totalDiscount?: StringNullableWithAggregatesFilter | string | null
    totalTransportation?: StringNullableWithAggregatesFilter | string | null
    totalExpenses?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    vendorId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type POItemsWhereInput = {
    AND?: Enumerable<POItemsWhereInput>
    OR?: Enumerable<POItemsWhereInput>
    NOT?: Enumerable<POItemsWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    po?: XOR<PORelationFilter, POWhereInput>
    poId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type POItemsOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    po?: POOrderByWithRelationInput
    poId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POItemsWhereUniqueInput = {
    id?: string
  }

  export type POItemsOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    poId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: POItemsCountOrderByAggregateInput
    _max?: POItemsMaxOrderByAggregateInput
    _min?: POItemsMinOrderByAggregateInput
  }

  export type POItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<POItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<POItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<POItemsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sku?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    short_desc?: StringNullableWithAggregatesFilter | string | null
    desc?: StringNullableWithAggregatesFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    poId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    invoiceStatus?: StringNullableFilter | string | null
    paymentStatus?: StringNullableFilter | string | null
    paindAmount?: StringNullableFilter | string | null
    pendingAmount?: StringNullableFilter | string | null
    totalPrice?: StringNullableFilter | string | null
    totalTax?: StringNullableFilter | string | null
    totalDiscount?: StringNullableFilter | string | null
    totalTransportation?: StringNullableFilter | string | null
    totalExpenses?: StringNullableFilter | string | null
    invoiceItems?: InvoiceItemsListRelationFilter
    buyerId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    invoiceItems?: InvoiceItemsOrderByRelationAggregateInput
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    invoiceStatus?: StringNullableWithAggregatesFilter | string | null
    paymentStatus?: StringNullableWithAggregatesFilter | string | null
    paindAmount?: StringNullableWithAggregatesFilter | string | null
    pendingAmount?: StringNullableWithAggregatesFilter | string | null
    totalPrice?: StringNullableWithAggregatesFilter | string | null
    totalTax?: StringNullableWithAggregatesFilter | string | null
    totalDiscount?: StringNullableWithAggregatesFilter | string | null
    totalTransportation?: StringNullableWithAggregatesFilter | string | null
    totalExpenses?: StringNullableWithAggregatesFilter | string | null
    buyerId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvoiceItemsWhereInput = {
    AND?: Enumerable<InvoiceItemsWhereInput>
    OR?: Enumerable<InvoiceItemsWhereInput>
    NOT?: Enumerable<InvoiceItemsWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    invoiceId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type InvoiceItemsOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    invoiceId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceItemsWhereUniqueInput = {
    id?: string
  }

  export type InvoiceItemsOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    invoiceId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: InvoiceItemsCountOrderByAggregateInput
    _max?: InvoiceItemsMaxOrderByAggregateInput
    _min?: InvoiceItemsMinOrderByAggregateInput
  }

  export type InvoiceItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceItemsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sku?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    short_desc?: StringNullableWithAggregatesFilter | string | null
    desc?: StringNullableWithAggregatesFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    invoiceId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    orderStatus?: StringNullableFilter | string | null
    paymentStatus?: StringNullableFilter | string | null
    paindAmount?: StringNullableFilter | string | null
    pendingAmount?: StringNullableFilter | string | null
    totalPrice?: StringNullableFilter | string | null
    totalTax?: StringNullableFilter | string | null
    totalDiscount?: StringNullableFilter | string | null
    totalTransportation?: StringNullableFilter | string | null
    totalExpenses?: StringNullableFilter | string | null
    orderItems?: OrderItemsListRelationFilter
    buyerId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    orderItems?: OrderItemsOrderByRelationAggregateInput
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderWhereUniqueInput = {
    id?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    orderStatus?: StringNullableWithAggregatesFilter | string | null
    paymentStatus?: StringNullableWithAggregatesFilter | string | null
    paindAmount?: StringNullableWithAggregatesFilter | string | null
    pendingAmount?: StringNullableWithAggregatesFilter | string | null
    totalPrice?: StringNullableWithAggregatesFilter | string | null
    totalTax?: StringNullableWithAggregatesFilter | string | null
    totalDiscount?: StringNullableWithAggregatesFilter | string | null
    totalTransportation?: StringNullableWithAggregatesFilter | string | null
    totalExpenses?: StringNullableWithAggregatesFilter | string | null
    buyerId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrderItemsWhereInput = {
    AND?: Enumerable<OrderItemsWhereInput>
    OR?: Enumerable<OrderItemsWhereInput>
    NOT?: Enumerable<OrderItemsWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    orderId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type OrderItemsOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    order?: OrderOrderByWithRelationInput
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderItemsWhereUniqueInput = {
    id?: string
  }

  export type OrderItemsOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: OrderItemsCountOrderByAggregateInput
    _max?: OrderItemsMaxOrderByAggregateInput
    _min?: OrderItemsMinOrderByAggregateInput
  }

  export type OrderItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderItemsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sku?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    short_desc?: StringNullableWithAggregatesFilter | string | null
    desc?: StringNullableWithAggregatesFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    orderId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentSlipsWhereInput = {
    AND?: Enumerable<PaymentSlipsWhereInput>
    OR?: Enumerable<PaymentSlipsWhereInput>
    NOT?: Enumerable<PaymentSlipsWhereInput>
    id?: StringFilter | string
    paymentType?: StringNullableFilter | string | null
    paymentTypeId?: StringNullableFilter | string | null
    paidAmount?: StringNullableFilter | string | null
    paymentMode?: StringNullableFilter | string | null
    paymentStatus?: StringNullableFilter | string | null
    paidBy?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type PaymentSlipsOrderByWithRelationInput = {
    id?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    paidAmount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    paidBy?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PaymentSlipsWhereUniqueInput = {
    id?: string
  }

  export type PaymentSlipsOrderByWithAggregationInput = {
    id?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    paidAmount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    paidBy?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: PaymentSlipsCountOrderByAggregateInput
    _max?: PaymentSlipsMaxOrderByAggregateInput
    _min?: PaymentSlipsMinOrderByAggregateInput
  }

  export type PaymentSlipsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentSlipsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentSlipsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentSlipsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    paymentType?: StringNullableWithAggregatesFilter | string | null
    paymentTypeId?: StringNullableWithAggregatesFilter | string | null
    paidAmount?: StringNullableWithAggregatesFilter | string | null
    paymentMode?: StringNullableWithAggregatesFilter | string | null
    paymentStatus?: StringNullableWithAggregatesFilter | string | null
    paidBy?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    addressTitle?: StringNullableFilter | string | null
    addressLine?: StringNullableFilter | string | null
    addressLine1?: StringNullableFilter | string | null
    addressLine2?: StringNullableFilter | string | null
    landmark?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    pincode?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    addressTitle?: SortOrder
    addressLine?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    landmark?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobile?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    id?: string
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    addressTitle?: SortOrder
    addressLine?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    landmark?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobile?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    addressTitle?: StringNullableWithAggregatesFilter | string | null
    addressLine?: StringNullableWithAggregatesFilter | string | null
    addressLine1?: StringNullableWithAggregatesFilter | string | null
    addressLine2?: StringNullableWithAggregatesFilter | string | null
    landmark?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    pincode?: StringNullableWithAggregatesFilter | string | null
    mobile?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ExpansesWhereInput = {
    AND?: Enumerable<ExpansesWhereInput>
    OR?: Enumerable<ExpansesWhereInput>
    NOT?: Enumerable<ExpansesWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    expensesType?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type ExpansesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ExpansesWhereUniqueInput = {
    id?: string
  }

  export type ExpansesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: ExpansesCountOrderByAggregateInput
    _max?: ExpansesMaxOrderByAggregateInput
    _min?: ExpansesMinOrderByAggregateInput
  }

  export type ExpansesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExpansesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExpansesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExpansesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    expensesType?: StringNullableWithAggregatesFilter | string | null
    amount?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: Enumerable<EmployeeWhereInput>
    OR?: Enumerable<EmployeeWhereInput>
    NOT?: Enumerable<EmployeeWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    departmentId?: StringFilter | string
    monthlyPay?: StringNullableFilter | string | null
    yearlyPay?: StringNullableFilter | string | null
    salary?: SalaryListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
    Attendance?: AttendanceListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    departmentId?: SortOrder
    monthlyPay?: SortOrder
    yearlyPay?: SortOrder
    salary?: SalaryOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    Attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = {
    id?: string
  }

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    monthlyPay?: SortOrder
    yearlyPay?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    departmentId?: StringWithAggregatesFilter | string
    monthlyPay?: StringNullableWithAggregatesFilter | string | null
    yearlyPay?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: Enumerable<DepartmentWhereInput>
    OR?: Enumerable<DepartmentWhereInput>
    NOT?: Enumerable<DepartmentWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    employees?: EmployeeListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type DepartmentWhereUniqueInput = {
    id?: string
  }

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: Enumerable<AttendanceWhereInput>
    OR?: Enumerable<AttendanceWhereInput>
    NOT?: Enumerable<AttendanceWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    from?: StringNullableFilter | string | null
    to?: StringNullableFilter | string | null
    presents?: StringNullableFilter | string | null
    absents?: StringNullableFilter | string | null
    paidLeaves?: StringNullableFilter | string | null
    Salary?: XOR<SalaryRelationFilter, SalaryWhereInput> | null
    salaryId?: StringNullableFilter | string | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    employeeId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    from?: SortOrder
    to?: SortOrder
    presents?: SortOrder
    absents?: SortOrder
    paidLeaves?: SortOrder
    Salary?: SalaryOrderByWithRelationInput
    salaryId?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AttendanceWhereUniqueInput = {
    id?: string
  }

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    from?: SortOrder
    to?: SortOrder
    presents?: SortOrder
    absents?: SortOrder
    paidLeaves?: SortOrder
    salaryId?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttendanceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttendanceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttendanceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    from?: StringNullableWithAggregatesFilter | string | null
    to?: StringNullableWithAggregatesFilter | string | null
    presents?: StringNullableWithAggregatesFilter | string | null
    absents?: StringNullableWithAggregatesFilter | string | null
    paidLeaves?: StringNullableWithAggregatesFilter | string | null
    salaryId?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SalaryWhereInput = {
    AND?: Enumerable<SalaryWhereInput>
    OR?: Enumerable<SalaryWhereInput>
    NOT?: Enumerable<SalaryWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    expensesType?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    from?: StringNullableFilter | string | null
    to?: StringNullableFilter | string | null
    attendance?: AttendanceListRelationFilter
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    employeeId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type SalaryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    from?: SortOrder
    to?: SortOrder
    attendance?: AttendanceOrderByRelationAggregateInput
    employee?: EmployeeOrderByWithRelationInput
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SalaryWhereUniqueInput = {
    id?: string
  }

  export type SalaryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    from?: SortOrder
    to?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    _count?: SalaryCountOrderByAggregateInput
    _max?: SalaryMaxOrderByAggregateInput
    _min?: SalaryMinOrderByAggregateInput
  }

  export type SalaryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalaryScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalaryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalaryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    expensesType?: StringNullableWithAggregatesFilter | string | null
    amount?: StringNullableWithAggregatesFilter | string | null
    from?: StringNullableWithAggregatesFilter | string | null
    to?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PermissionsCreateInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    User?: UserCreateNestedOneWithoutPermissionInput
    RolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    userId?: string | null
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionsUpdateInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPermissionInput
    RolePermission?: RolePermissionUpdateManyWithoutPermissionInput
  }

  export type PermissionsUncheckedUpdateInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionInput
  }

  export type PermissionsCreateManyInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    userId?: string | null
  }

  export type PermissionsUpdateManyMutationInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUncheckedUpdateManyInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    permission?: PermissionsCreateNestedManyWithoutUserInput
    expenses?: ExpansesCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    departments?: DepartmentCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    permission?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpansesUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserInput
    permission?: PermissionsUpdateManyWithoutUserInput
    expenses?: ExpansesUpdateManyWithoutUserInput
    employees?: EmployeeUpdateManyWithoutUserInput
    departments?: DepartmentUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserInput
    permission?: PermissionsUncheckedUpdateManyWithoutUserInput
    expenses?: ExpansesUncheckedUpdateManyWithoutUserInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserInput
    departments?: DepartmentUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    products?: ProductCreateNestedManyWithoutWarehouseInput
    racks?: RacksCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
    racks?: RacksUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutWarehouseInput
    racks?: RacksUpdateManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutWarehouseInput
    racks?: RacksUncheckedUpdateManyWithoutWarehouseInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
  }

  export type WarehouseUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RacksCreateInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    shelf?: ShelfCreateNestedManyWithoutRacksInput
    userId?: string | null
    warehouse: WarehouseCreateNestedOneWithoutRacksInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksUncheckedCreateInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    shelf?: ShelfUncheckedCreateNestedManyWithoutRacksInput
    userId?: string | null
    warehouseId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: ShelfUpdateManyWithoutRacksInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutRacksInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: ShelfUncheckedUpdateManyWithoutRacksInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksCreateManyInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    userId?: string | null
    warehouseId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfCreateInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    Product?: ProductCreateNestedManyWithoutShelfInput
    racks: RacksCreateNestedOneWithoutShelfInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUncheckedCreateInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutShelfInput
    rackId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutShelfInput
    racks?: RacksUpdateOneRequiredWithoutShelfInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutShelfInput
    rackId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfCreateManyInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    rackId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    rackId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouse: WarehouseCreateNestedOneWithoutProductsInput
    shelf: ShelfCreateNestedOneWithoutProductInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouseId: string
    shelfId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutProductsInput
    shelf?: ShelfUpdateOneRequiredWithoutProductInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouseId: string
    shelfId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    title?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    title?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RoleUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInput = {
    id?: string
    title?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    roleId?: string | null
    permission: PermissionsCreateNestedOneWithoutRolePermissionInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId?: string | null
    permissionId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionUpdateInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: PermissionsUpdateOneRequiredWithoutRolePermissionInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId?: string | null
    permissionId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POCreateInput = {
    id?: string
    poStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    poItem?: POItemsCreateNestedManyWithoutPoInput
    userId?: string | null
    vendorId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POUncheckedCreateInput = {
    id?: string
    poStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    poItem?: POItemsUncheckedCreateNestedManyWithoutPoInput
    userId?: string | null
    vendorId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POUpdateInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    poItem?: POItemsUpdateManyWithoutPoInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POUncheckedUpdateInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    poItem?: POItemsUncheckedUpdateManyWithoutPoInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POCreateManyInput = {
    id?: string
    poStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    userId?: string | null
    vendorId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POUpdateManyMutationInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POUncheckedUpdateManyInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    po: POCreateNestedOneWithoutPoItemInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsUncheckedCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    poId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    po?: POUpdateOneRequiredWithoutPoItemInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsUncheckedUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    poId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsCreateManyInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    poId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsUncheckedUpdateManyInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    poId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    invoiceItems?: InvoiceItemsCreateNestedManyWithoutInvoiceInput
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    invoiceItems?: InvoiceItemsUncheckedCreateNestedManyWithoutInvoiceInput
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceUpdateInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemsUpdateManyWithoutInvoiceInput
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemsUncheckedUpdateManyWithoutInvoiceInput
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsUncheckedCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    invoiceId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsUncheckedUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    invoiceId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsCreateManyInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    invoiceId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsUncheckedUpdateManyInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    invoiceId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    orderItems?: OrderItemsCreateNestedManyWithoutOrderInput
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutOrderInput
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderUpdateInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemsUpdateManyWithoutOrderInput
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemsUncheckedUpdateManyWithoutOrderInput
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    orderStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    order: OrderCreateNestedOneWithoutOrderItemsInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsUncheckedCreateInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    orderId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    order?: OrderUpdateOneRequiredWithoutOrderItemsInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    orderId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateManyInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    orderId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsUpdateManyMutationInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateManyInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    orderId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentSlipsCreateInput = {
    id?: string
    paymentType?: string | null
    paymentTypeId?: string | null
    paidAmount?: string | null
    paymentMode?: string | null
    paymentStatus?: string | null
    paidBy?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type PaymentSlipsUncheckedCreateInput = {
    id?: string
    paymentType?: string | null
    paymentTypeId?: string | null
    paidAmount?: string | null
    paymentMode?: string | null
    paymentStatus?: string | null
    paidBy?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type PaymentSlipsUpdateInput = {
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentSlipsUncheckedUpdateInput = {
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentSlipsCreateManyInput = {
    id?: string
    paymentType?: string | null
    paymentTypeId?: string | null
    paidAmount?: string | null
    paymentMode?: string | null
    paymentStatus?: string | null
    paidBy?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type PaymentSlipsUpdateManyMutationInput = {
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentSlipsUncheckedUpdateManyInput = {
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAmount?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMode?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    user: UserCreateNestedOneWithoutAddressInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAddressInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesCreateInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    user: UserCreateNestedOneWithoutExpensesInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesUncheckedCreateInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutExpensesInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesCreateManyInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    title?: string | null
    department: DepartmentCreateNestedOneWithoutEmployeesInput
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeesInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutEmployeesInput
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeesInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUncheckedUpdateManyWithoutEmployeeInput
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    title?: string | null
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    user: UserCreateNestedOneWithoutDepartmentsInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    title?: string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUpdateManyWithoutDepartmentInput
    user?: UserUpdateOneRequiredWithoutDepartmentsInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentInput
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyInput = {
    id?: string
    title?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    Salary?: SalaryCreateNestedOneWithoutAttendanceInput
    Employee?: EmployeeCreateNestedOneWithoutAttendanceInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    salaryId?: string | null
    employeeId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: SalaryUpdateOneWithoutAttendanceInput
    Employee?: EmployeeUpdateOneWithoutAttendanceInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    salaryId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    salaryId?: string | null
    employeeId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    salaryId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    attendance?: AttendanceCreateNestedManyWithoutSalaryInput
    employee: EmployeeCreateNestedOneWithoutSalaryInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUncheckedCreateInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSalaryInput
    employeeId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutSalaryInput
    employee?: EmployeeUpdateOneRequiredWithoutSalaryInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutSalaryInput
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateManyInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    employeeId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    actions?: SortOrder
    parents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    userId?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    parents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    userId?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    parents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    userId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type PermissionsListRelationFilter = {
    every?: PermissionsWhereInput
    some?: PermissionsWhereInput
    none?: PermissionsWhereInput
  }

  export type ExpansesListRelationFilter = {
    every?: ExpansesWhereInput
    some?: ExpansesWhereInput
    none?: ExpansesWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpansesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    mobile?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type RacksListRelationFilter = {
    every?: RacksWhereInput
    some?: RacksWhereInput
    none?: RacksWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RacksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    staff?: SortOrder
    addressId?: SortOrder
    incharge?: SortOrder
    userId?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    staff?: SortOrder
    incharge?: SortOrder
    userId?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    staff?: SortOrder
    incharge?: SortOrder
    userId?: SortOrder
  }

  export type ShelfListRelationFilter = {
    every?: ShelfWhereInput
    some?: ShelfWhereInput
    none?: ShelfWhereInput
  }

  export type WarehouseRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type ShelfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RacksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RacksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RacksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RacksRelationFilter = {
    is?: RacksWhereInput
    isNot?: RacksWhereInput
  }

  export type ShelfCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    totalSpace?: SortOrder
    availableSpace?: SortOrder
    rackId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ShelfMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    totalSpace?: SortOrder
    availableSpace?: SortOrder
    rackId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ShelfMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    length?: SortOrder
    width?: SortOrder
    height?: SortOrder
    side?: SortOrder
    totalSpace?: SortOrder
    availableSpace?: SortOrder
    rackId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ShelfRelationFilter = {
    is?: ShelfWhereInput
    isNot?: ShelfWhereInput
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    bulletPoints?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    purchase_price?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    shelfId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    shelfId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    shelfId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PermissionsRelationFilter = {
    is?: PermissionsWhereInput
    isNot?: PermissionsWhereInput
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POItemsListRelationFilter = {
    every?: POItemsWhereInput
    some?: POItemsWhereInput
    none?: POItemsWhereInput
  }

  export type POItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POCountOrderByAggregateInput = {
    id?: SortOrder
    poStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POMaxOrderByAggregateInput = {
    id?: SortOrder
    poStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POMinOrderByAggregateInput = {
    id?: SortOrder
    poStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PORelationFilter = {
    is?: POWhereInput
    isNot?: POWhereInput
  }

  export type POItemsCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    poId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    poId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type POItemsMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    poId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceItemsListRelationFilter = {
    every?: InvoiceItemsWhereInput
    some?: InvoiceItemsWhereInput
    none?: InvoiceItemsWhereInput
  }

  export type InvoiceItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemsCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    invoiceId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    invoiceId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type InvoiceItemsMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    invoiceId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderItemsListRelationFilter = {
    every?: OrderItemsWhereInput
    some?: OrderItemsWhereInput
    none?: OrderItemsWhereInput
  }

  export type OrderItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    paymentStatus?: SortOrder
    paindAmount?: SortOrder
    pendingAmount?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscount?: SortOrder
    totalTransportation?: SortOrder
    totalExpenses?: SortOrder
    buyerId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemsCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    categories?: SortOrder
    variation?: SortOrder
    images?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrderItemsMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    title?: SortOrder
    short_desc?: SortOrder
    desc?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PaymentSlipsCountOrderByAggregateInput = {
    id?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    paidAmount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    paidBy?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PaymentSlipsMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    paidAmount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    paidBy?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PaymentSlipsMinOrderByAggregateInput = {
    id?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    paidAmount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    paidBy?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    addressTitle?: SortOrder
    addressLine?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    landmark?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobile?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    addressTitle?: SortOrder
    addressLine?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    landmark?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobile?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    addressTitle?: SortOrder
    addressLine?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    landmark?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobile?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ExpansesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ExpansesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ExpansesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type SalaryListRelationFilter = {
    every?: SalaryWhereInput
    some?: SalaryWhereInput
    none?: SalaryWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type SalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    monthlyPay?: SortOrder
    yearlyPay?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    monthlyPay?: SortOrder
    yearlyPay?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    departmentId?: SortOrder
    monthlyPay?: SortOrder
    yearlyPay?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SalaryRelationFilter = {
    is?: SalaryWhereInput | null
    isNot?: SalaryWhereInput | null
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    from?: SortOrder
    to?: SortOrder
    presents?: SortOrder
    absents?: SortOrder
    paidLeaves?: SortOrder
    salaryId?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    from?: SortOrder
    to?: SortOrder
    presents?: SortOrder
    absents?: SortOrder
    paidLeaves?: SortOrder
    salaryId?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    from?: SortOrder
    to?: SortOrder
    presents?: SortOrder
    absents?: SortOrder
    paidLeaves?: SortOrder
    salaryId?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SalaryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    from?: SortOrder
    to?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    from?: SortOrder
    to?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type SalaryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    expensesType?: SortOrder
    amount?: SortOrder
    from?: SortOrder
    to?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type PermissionsCreateactionsInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutPermissionInput = {
    create?: XOR<UserCreateWithoutPermissionInput, UserUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionInput
    connect?: UserWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: Enumerable<RolePermissionWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type PermissionsUpdateactionsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutPermissionInput = {
    create?: XOR<UserCreateWithoutPermissionInput, UserUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionInput
    upsert?: UserUpsertWithoutPermissionInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPermissionInput, UserUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    create?: XOR<Enumerable<RolePermissionCreateWithoutPermissionInput>, Enumerable<RolePermissionUncheckedCreateWithoutPermissionInput>>
    connectOrCreate?: Enumerable<RolePermissionCreateOrConnectWithoutPermissionInput>
    upsert?: Enumerable<RolePermissionUpsertWithWhereUniqueWithoutPermissionInput>
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: Enumerable<RolePermissionWhereUniqueInput>
    disconnect?: Enumerable<RolePermissionWhereUniqueInput>
    delete?: Enumerable<RolePermissionWhereUniqueInput>
    connect?: Enumerable<RolePermissionWhereUniqueInput>
    update?: Enumerable<RolePermissionUpdateWithWhereUniqueWithoutPermissionInput>
    updateMany?: Enumerable<RolePermissionUpdateManyWithWhereWithoutPermissionInput>
    deleteMany?: Enumerable<RolePermissionScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type PermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutUserInput>, Enumerable<PermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutUserInput>
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionsWhereUniqueInput>
  }

  export type ExpansesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExpansesCreateWithoutUserInput>, Enumerable<ExpansesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExpansesCreateOrConnectWithoutUserInput>
    createMany?: ExpansesCreateManyUserInputEnvelope
    connect?: Enumerable<ExpansesWhereUniqueInput>
  }

  export type EmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type DepartmentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutUserInput>, Enumerable<DepartmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutUserInput>
    createMany?: DepartmentCreateManyUserInputEnvelope
    connect?: Enumerable<DepartmentWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type PermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutUserInput>, Enumerable<PermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutUserInput>
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionsWhereUniqueInput>
  }

  export type ExpansesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExpansesCreateWithoutUserInput>, Enumerable<ExpansesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExpansesCreateOrConnectWithoutUserInput>
    createMany?: ExpansesCreateManyUserInputEnvelope
    connect?: Enumerable<ExpansesWhereUniqueInput>
  }

  export type EmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type DepartmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutUserInput>, Enumerable<DepartmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutUserInput>
    createMany?: DepartmentCreateManyUserInputEnvelope
    connect?: Enumerable<DepartmentWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type PermissionsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutUserInput>, Enumerable<PermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: Enumerable<PermissionsWhereUniqueInput>
    disconnect?: Enumerable<PermissionsWhereUniqueInput>
    delete?: Enumerable<PermissionsWhereUniqueInput>
    connect?: Enumerable<PermissionsWhereUniqueInput>
    update?: Enumerable<PermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PermissionsScalarWhereInput>
  }

  export type ExpansesUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ExpansesCreateWithoutUserInput>, Enumerable<ExpansesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExpansesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExpansesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExpansesCreateManyUserInputEnvelope
    set?: Enumerable<ExpansesWhereUniqueInput>
    disconnect?: Enumerable<ExpansesWhereUniqueInput>
    delete?: Enumerable<ExpansesWhereUniqueInput>
    connect?: Enumerable<ExpansesWhereUniqueInput>
    update?: Enumerable<ExpansesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExpansesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExpansesScalarWhereInput>
  }

  export type EmployeeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type DepartmentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutUserInput>, Enumerable<DepartmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DepartmentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DepartmentCreateManyUserInputEnvelope
    set?: Enumerable<DepartmentWhereUniqueInput>
    disconnect?: Enumerable<DepartmentWhereUniqueInput>
    delete?: Enumerable<DepartmentWhereUniqueInput>
    connect?: Enumerable<DepartmentWhereUniqueInput>
    update?: Enumerable<DepartmentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DepartmentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DepartmentScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserInput>, Enumerable<AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AddressCreateManyUserInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type PermissionsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionsCreateWithoutUserInput>, Enumerable<PermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: Enumerable<PermissionsWhereUniqueInput>
    disconnect?: Enumerable<PermissionsWhereUniqueInput>
    delete?: Enumerable<PermissionsWhereUniqueInput>
    connect?: Enumerable<PermissionsWhereUniqueInput>
    update?: Enumerable<PermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PermissionsScalarWhereInput>
  }

  export type ExpansesUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ExpansesCreateWithoutUserInput>, Enumerable<ExpansesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExpansesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExpansesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExpansesCreateManyUserInputEnvelope
    set?: Enumerable<ExpansesWhereUniqueInput>
    disconnect?: Enumerable<ExpansesWhereUniqueInput>
    delete?: Enumerable<ExpansesWhereUniqueInput>
    connect?: Enumerable<ExpansesWhereUniqueInput>
    update?: Enumerable<ExpansesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExpansesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExpansesScalarWhereInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutUserInput>, Enumerable<EmployeeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type DepartmentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutUserInput>, Enumerable<DepartmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DepartmentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DepartmentCreateManyUserInputEnvelope
    set?: Enumerable<DepartmentWhereUniqueInput>
    disconnect?: Enumerable<DepartmentWhereUniqueInput>
    delete?: Enumerable<DepartmentWhereUniqueInput>
    connect?: Enumerable<DepartmentWhereUniqueInput>
    update?: Enumerable<DepartmentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DepartmentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DepartmentScalarWhereInput>
  }

  export type WarehouseCreateaddressIdInput = {
    set: Enumerable<string>
  }

  export type ProductCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<ProductCreateWithoutWarehouseInput>, Enumerable<ProductUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutWarehouseInput>
    createMany?: ProductCreateManyWarehouseInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RacksCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<RacksCreateWithoutWarehouseInput>, Enumerable<RacksUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<RacksCreateOrConnectWithoutWarehouseInput>
    createMany?: RacksCreateManyWarehouseInputEnvelope
    connect?: Enumerable<RacksWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<ProductCreateWithoutWarehouseInput>, Enumerable<ProductUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutWarehouseInput>
    createMany?: ProductCreateManyWarehouseInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RacksUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<RacksCreateWithoutWarehouseInput>, Enumerable<RacksUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<RacksCreateOrConnectWithoutWarehouseInput>
    createMany?: RacksCreateManyWarehouseInputEnvelope
    connect?: Enumerable<RacksWhereUniqueInput>
  }

  export type WarehouseUpdateaddressIdInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdateManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<ProductCreateWithoutWarehouseInput>, Enumerable<ProductUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutWarehouseInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutWarehouseInput>
    createMany?: ProductCreateManyWarehouseInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutWarehouseInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutWarehouseInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type RacksUpdateManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<RacksCreateWithoutWarehouseInput>, Enumerable<RacksUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<RacksCreateOrConnectWithoutWarehouseInput>
    upsert?: Enumerable<RacksUpsertWithWhereUniqueWithoutWarehouseInput>
    createMany?: RacksCreateManyWarehouseInputEnvelope
    set?: Enumerable<RacksWhereUniqueInput>
    disconnect?: Enumerable<RacksWhereUniqueInput>
    delete?: Enumerable<RacksWhereUniqueInput>
    connect?: Enumerable<RacksWhereUniqueInput>
    update?: Enumerable<RacksUpdateWithWhereUniqueWithoutWarehouseInput>
    updateMany?: Enumerable<RacksUpdateManyWithWhereWithoutWarehouseInput>
    deleteMany?: Enumerable<RacksScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<ProductCreateWithoutWarehouseInput>, Enumerable<ProductUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutWarehouseInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutWarehouseInput>
    createMany?: ProductCreateManyWarehouseInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutWarehouseInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutWarehouseInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type RacksUncheckedUpdateManyWithoutWarehouseInput = {
    create?: XOR<Enumerable<RacksCreateWithoutWarehouseInput>, Enumerable<RacksUncheckedCreateWithoutWarehouseInput>>
    connectOrCreate?: Enumerable<RacksCreateOrConnectWithoutWarehouseInput>
    upsert?: Enumerable<RacksUpsertWithWhereUniqueWithoutWarehouseInput>
    createMany?: RacksCreateManyWarehouseInputEnvelope
    set?: Enumerable<RacksWhereUniqueInput>
    disconnect?: Enumerable<RacksWhereUniqueInput>
    delete?: Enumerable<RacksWhereUniqueInput>
    connect?: Enumerable<RacksWhereUniqueInput>
    update?: Enumerable<RacksUpdateWithWhereUniqueWithoutWarehouseInput>
    updateMany?: Enumerable<RacksUpdateManyWithWhereWithoutWarehouseInput>
    deleteMany?: Enumerable<RacksScalarWhereInput>
  }

  export type ShelfCreateNestedManyWithoutRacksInput = {
    create?: XOR<Enumerable<ShelfCreateWithoutRacksInput>, Enumerable<ShelfUncheckedCreateWithoutRacksInput>>
    connectOrCreate?: Enumerable<ShelfCreateOrConnectWithoutRacksInput>
    createMany?: ShelfCreateManyRacksInputEnvelope
    connect?: Enumerable<ShelfWhereUniqueInput>
  }

  export type WarehouseCreateNestedOneWithoutRacksInput = {
    create?: XOR<WarehouseCreateWithoutRacksInput, WarehouseUncheckedCreateWithoutRacksInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutRacksInput
    connect?: WarehouseWhereUniqueInput
  }

  export type ShelfUncheckedCreateNestedManyWithoutRacksInput = {
    create?: XOR<Enumerable<ShelfCreateWithoutRacksInput>, Enumerable<ShelfUncheckedCreateWithoutRacksInput>>
    connectOrCreate?: Enumerable<ShelfCreateOrConnectWithoutRacksInput>
    createMany?: ShelfCreateManyRacksInputEnvelope
    connect?: Enumerable<ShelfWhereUniqueInput>
  }

  export type ShelfUpdateManyWithoutRacksInput = {
    create?: XOR<Enumerable<ShelfCreateWithoutRacksInput>, Enumerable<ShelfUncheckedCreateWithoutRacksInput>>
    connectOrCreate?: Enumerable<ShelfCreateOrConnectWithoutRacksInput>
    upsert?: Enumerable<ShelfUpsertWithWhereUniqueWithoutRacksInput>
    createMany?: ShelfCreateManyRacksInputEnvelope
    set?: Enumerable<ShelfWhereUniqueInput>
    disconnect?: Enumerable<ShelfWhereUniqueInput>
    delete?: Enumerable<ShelfWhereUniqueInput>
    connect?: Enumerable<ShelfWhereUniqueInput>
    update?: Enumerable<ShelfUpdateWithWhereUniqueWithoutRacksInput>
    updateMany?: Enumerable<ShelfUpdateManyWithWhereWithoutRacksInput>
    deleteMany?: Enumerable<ShelfScalarWhereInput>
  }

  export type WarehouseUpdateOneRequiredWithoutRacksInput = {
    create?: XOR<WarehouseCreateWithoutRacksInput, WarehouseUncheckedCreateWithoutRacksInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutRacksInput
    upsert?: WarehouseUpsertWithoutRacksInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<WarehouseUpdateWithoutRacksInput, WarehouseUncheckedUpdateWithoutRacksInput>
  }

  export type ShelfUncheckedUpdateManyWithoutRacksInput = {
    create?: XOR<Enumerable<ShelfCreateWithoutRacksInput>, Enumerable<ShelfUncheckedCreateWithoutRacksInput>>
    connectOrCreate?: Enumerable<ShelfCreateOrConnectWithoutRacksInput>
    upsert?: Enumerable<ShelfUpsertWithWhereUniqueWithoutRacksInput>
    createMany?: ShelfCreateManyRacksInputEnvelope
    set?: Enumerable<ShelfWhereUniqueInput>
    disconnect?: Enumerable<ShelfWhereUniqueInput>
    delete?: Enumerable<ShelfWhereUniqueInput>
    connect?: Enumerable<ShelfWhereUniqueInput>
    update?: Enumerable<ShelfUpdateWithWhereUniqueWithoutRacksInput>
    updateMany?: Enumerable<ShelfUpdateManyWithWhereWithoutRacksInput>
    deleteMany?: Enumerable<ShelfScalarWhereInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProductCreateNestedManyWithoutShelfInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShelfInput>, Enumerable<ProductUncheckedCreateWithoutShelfInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShelfInput>
    createMany?: ProductCreateManyShelfInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type RacksCreateNestedOneWithoutShelfInput = {
    create?: XOR<RacksCreateWithoutShelfInput, RacksUncheckedCreateWithoutShelfInput>
    connectOrCreate?: RacksCreateOrConnectWithoutShelfInput
    connect?: RacksWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutShelfInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShelfInput>, Enumerable<ProductUncheckedCreateWithoutShelfInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShelfInput>
    createMany?: ProductCreateManyShelfInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutShelfInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShelfInput>, Enumerable<ProductUncheckedCreateWithoutShelfInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShelfInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutShelfInput>
    createMany?: ProductCreateManyShelfInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutShelfInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutShelfInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type RacksUpdateOneRequiredWithoutShelfInput = {
    create?: XOR<RacksCreateWithoutShelfInput, RacksUncheckedCreateWithoutShelfInput>
    connectOrCreate?: RacksCreateOrConnectWithoutShelfInput
    upsert?: RacksUpsertWithoutShelfInput
    connect?: RacksWhereUniqueInput
    update?: XOR<RacksUpdateWithoutShelfInput, RacksUncheckedUpdateWithoutShelfInput>
  }

  export type ProductUncheckedUpdateManyWithoutShelfInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShelfInput>, Enumerable<ProductUncheckedCreateWithoutShelfInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShelfInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutShelfInput>
    createMany?: ProductCreateManyShelfInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutShelfInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutShelfInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductCreatebulletPointsInput = {
    set: Enumerable<string>
  }

  export type ProductCreatecategoriesInput = {
    set: Enumerable<string>
  }

  export type ProductCreatevariationInput = {
    set: Enumerable<string>
  }

  export type ProductCreateimagesInput = {
    set: Enumerable<string>
  }

  export type ProductCreatepriceInput = {
    set: Enumerable<string>
  }

  export type ProductCreatequantityInput = {
    set: Enumerable<string>
  }

  export type ProductCreatepurchase_priceInput = {
    set: Enumerable<string>
  }

  export type WarehouseCreateNestedOneWithoutProductsInput = {
    create?: XOR<WarehouseCreateWithoutProductsInput, WarehouseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type ShelfCreateNestedOneWithoutProductInput = {
    create?: XOR<ShelfCreateWithoutProductInput, ShelfUncheckedCreateWithoutProductInput>
    connectOrCreate?: ShelfCreateOrConnectWithoutProductInput
    connect?: ShelfWhereUniqueInput
  }

  export type ProductUpdatebulletPointsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatecategoriesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatevariationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatepriceInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatequantityInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ProductUpdatepurchase_priceInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type WarehouseUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<WarehouseCreateWithoutProductsInput, WarehouseUncheckedCreateWithoutProductsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductsInput
    upsert?: WarehouseUpsertWithoutProductsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<WarehouseUpdateWithoutProductsInput, WarehouseUncheckedUpdateWithoutProductsInput>
  }

  export type ShelfUpdateOneRequiredWithoutProductInput = {
    create?: XOR<ShelfCreateWithoutProductInput, ShelfUncheckedCreateWithoutProductInput>
    connectOrCreate?: ShelfCreateOrConnectWithoutProductInput
    upsert?: ShelfUpsertWithoutProductInput
    connect?: ShelfWhereUniqueInput
    update?: XOR<ShelfUpdateWithoutProductInput, ShelfUncheckedUpdateWithoutProductInput>
  }

  export type PermissionsCreateNestedOneWithoutRolePermissionInput = {
    create?: XOR<PermissionsCreateWithoutRolePermissionInput, PermissionsUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutRolePermissionInput
    connect?: PermissionsWhereUniqueInput
  }

  export type PermissionsUpdateOneRequiredWithoutRolePermissionInput = {
    create?: XOR<PermissionsCreateWithoutRolePermissionInput, PermissionsUncheckedCreateWithoutRolePermissionInput>
    connectOrCreate?: PermissionsCreateOrConnectWithoutRolePermissionInput
    upsert?: PermissionsUpsertWithoutRolePermissionInput
    connect?: PermissionsWhereUniqueInput
    update?: XOR<PermissionsUpdateWithoutRolePermissionInput, PermissionsUncheckedUpdateWithoutRolePermissionInput>
  }

  export type POItemsCreateNestedManyWithoutPoInput = {
    create?: XOR<Enumerable<POItemsCreateWithoutPoInput>, Enumerable<POItemsUncheckedCreateWithoutPoInput>>
    connectOrCreate?: Enumerable<POItemsCreateOrConnectWithoutPoInput>
    createMany?: POItemsCreateManyPoInputEnvelope
    connect?: Enumerable<POItemsWhereUniqueInput>
  }

  export type POItemsUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<Enumerable<POItemsCreateWithoutPoInput>, Enumerable<POItemsUncheckedCreateWithoutPoInput>>
    connectOrCreate?: Enumerable<POItemsCreateOrConnectWithoutPoInput>
    createMany?: POItemsCreateManyPoInputEnvelope
    connect?: Enumerable<POItemsWhereUniqueInput>
  }

  export type POItemsUpdateManyWithoutPoInput = {
    create?: XOR<Enumerable<POItemsCreateWithoutPoInput>, Enumerable<POItemsUncheckedCreateWithoutPoInput>>
    connectOrCreate?: Enumerable<POItemsCreateOrConnectWithoutPoInput>
    upsert?: Enumerable<POItemsUpsertWithWhereUniqueWithoutPoInput>
    createMany?: POItemsCreateManyPoInputEnvelope
    set?: Enumerable<POItemsWhereUniqueInput>
    disconnect?: Enumerable<POItemsWhereUniqueInput>
    delete?: Enumerable<POItemsWhereUniqueInput>
    connect?: Enumerable<POItemsWhereUniqueInput>
    update?: Enumerable<POItemsUpdateWithWhereUniqueWithoutPoInput>
    updateMany?: Enumerable<POItemsUpdateManyWithWhereWithoutPoInput>
    deleteMany?: Enumerable<POItemsScalarWhereInput>
  }

  export type POItemsUncheckedUpdateManyWithoutPoInput = {
    create?: XOR<Enumerable<POItemsCreateWithoutPoInput>, Enumerable<POItemsUncheckedCreateWithoutPoInput>>
    connectOrCreate?: Enumerable<POItemsCreateOrConnectWithoutPoInput>
    upsert?: Enumerable<POItemsUpsertWithWhereUniqueWithoutPoInput>
    createMany?: POItemsCreateManyPoInputEnvelope
    set?: Enumerable<POItemsWhereUniqueInput>
    disconnect?: Enumerable<POItemsWhereUniqueInput>
    delete?: Enumerable<POItemsWhereUniqueInput>
    connect?: Enumerable<POItemsWhereUniqueInput>
    update?: Enumerable<POItemsUpdateWithWhereUniqueWithoutPoInput>
    updateMany?: Enumerable<POItemsUpdateManyWithWhereWithoutPoInput>
    deleteMany?: Enumerable<POItemsScalarWhereInput>
  }

  export type POItemsCreatecategoriesInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatevariationInput = {
    set: Enumerable<string>
  }

  export type POItemsCreateimagesInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatepriceInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatetaxRateInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatetaxAmountInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatediscountAmountInput = {
    set: Enumerable<string>
  }

  export type POItemsCreatequantityInput = {
    set: Enumerable<string>
  }

  export type POCreateNestedOneWithoutPoItemInput = {
    create?: XOR<POCreateWithoutPoItemInput, POUncheckedCreateWithoutPoItemInput>
    connectOrCreate?: POCreateOrConnectWithoutPoItemInput
    connect?: POWhereUniqueInput
  }

  export type POItemsUpdatecategoriesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatevariationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatepriceInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatetaxRateInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatetaxAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatediscountAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POItemsUpdatequantityInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type POUpdateOneRequiredWithoutPoItemInput = {
    create?: XOR<POCreateWithoutPoItemInput, POUncheckedCreateWithoutPoItemInput>
    connectOrCreate?: POCreateOrConnectWithoutPoItemInput
    upsert?: POUpsertWithoutPoItemInput
    connect?: POWhereUniqueInput
    update?: XOR<POUpdateWithoutPoItemInput, POUncheckedUpdateWithoutPoItemInput>
  }

  export type InvoiceItemsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemsCreateWithoutInvoiceInput>, Enumerable<InvoiceItemsUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemsCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceItemsCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceItemsWhereUniqueInput>
  }

  export type InvoiceItemsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemsCreateWithoutInvoiceInput>, Enumerable<InvoiceItemsUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemsCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceItemsCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceItemsWhereUniqueInput>
  }

  export type InvoiceItemsUpdateManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemsCreateWithoutInvoiceInput>, Enumerable<InvoiceItemsUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemsCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceItemsUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceItemsCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceItemsWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemsWhereUniqueInput>
    delete?: Enumerable<InvoiceItemsWhereUniqueInput>
    connect?: Enumerable<InvoiceItemsWhereUniqueInput>
    update?: Enumerable<InvoiceItemsUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceItemsUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceItemsScalarWhereInput>
  }

  export type InvoiceItemsUncheckedUpdateManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceItemsCreateWithoutInvoiceInput>, Enumerable<InvoiceItemsUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceItemsCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceItemsUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceItemsCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceItemsWhereUniqueInput>
    disconnect?: Enumerable<InvoiceItemsWhereUniqueInput>
    delete?: Enumerable<InvoiceItemsWhereUniqueInput>
    connect?: Enumerable<InvoiceItemsWhereUniqueInput>
    update?: Enumerable<InvoiceItemsUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceItemsUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceItemsScalarWhereInput>
  }

  export type InvoiceItemsCreatecategoriesInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatevariationInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreateimagesInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatepriceInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatetaxRateInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatetaxAmountInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatediscountAmountInput = {
    set: Enumerable<string>
  }

  export type InvoiceItemsCreatequantityInput = {
    set: Enumerable<string>
  }

  export type InvoiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceItemsUpdatecategoriesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatevariationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatepriceInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatetaxRateInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatetaxAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatediscountAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceItemsUpdatequantityInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type InvoiceUpdateOneRequiredWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: InvoiceUpsertWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type OrderItemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemsCreateWithoutOrderInput>, Enumerable<OrderItemsUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemsCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemsWhereUniqueInput>
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemsCreateWithoutOrderInput>, Enumerable<OrderItemsUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemsCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemsWhereUniqueInput>
  }

  export type OrderItemsUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemsCreateWithoutOrderInput>, Enumerable<OrderItemsUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemsCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemsUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemsWhereUniqueInput>
    disconnect?: Enumerable<OrderItemsWhereUniqueInput>
    delete?: Enumerable<OrderItemsWhereUniqueInput>
    connect?: Enumerable<OrderItemsWhereUniqueInput>
    update?: Enumerable<OrderItemsUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemsUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemsScalarWhereInput>
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemsCreateWithoutOrderInput>, Enumerable<OrderItemsUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemsCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemsUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemsCreateManyOrderInputEnvelope
    set?: Enumerable<OrderItemsWhereUniqueInput>
    disconnect?: Enumerable<OrderItemsWhereUniqueInput>
    delete?: Enumerable<OrderItemsWhereUniqueInput>
    connect?: Enumerable<OrderItemsWhereUniqueInput>
    update?: Enumerable<OrderItemsUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemsUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemsScalarWhereInput>
  }

  export type OrderItemsCreatecategoriesInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatevariationInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreateimagesInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatepriceInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatetaxRateInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatetaxAmountInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatediscountAmountInput = {
    set: Enumerable<string>
  }

  export type OrderItemsCreatequantityInput = {
    set: Enumerable<string>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderItemsUpdatecategoriesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatevariationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatepriceInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatetaxRateInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatetaxAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatediscountAmountInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderItemsUpdatequantityInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserCreateNestedOneWithoutExpensesInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExpensesInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    upsert?: UserUpsertWithoutExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SalaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<SalaryCreateWithoutEmployeeInput>, Enumerable<SalaryUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<SalaryCreateOrConnectWithoutEmployeeInput>
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: Enumerable<SalaryWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    connect?: UserWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutEmployeeInput>, Enumerable<AttendanceUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutEmployeeInput>
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: Enumerable<AttendanceWhereUniqueInput>
  }

  export type SalaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<SalaryCreateWithoutEmployeeInput>, Enumerable<SalaryUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<SalaryCreateOrConnectWithoutEmployeeInput>
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: Enumerable<SalaryWhereUniqueInput>
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutEmployeeInput>, Enumerable<AttendanceUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutEmployeeInput>
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: Enumerable<AttendanceWhereUniqueInput>
  }

  export type DepartmentUpdateOneRequiredWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type SalaryUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<SalaryCreateWithoutEmployeeInput>, Enumerable<SalaryUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<SalaryCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<SalaryUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: Enumerable<SalaryWhereUniqueInput>
    disconnect?: Enumerable<SalaryWhereUniqueInput>
    delete?: Enumerable<SalaryWhereUniqueInput>
    connect?: Enumerable<SalaryWhereUniqueInput>
    update?: Enumerable<SalaryUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<SalaryUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<SalaryScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeesInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    upsert?: UserUpsertWithoutEmployeesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
  }

  export type AttendanceUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutEmployeeInput>, Enumerable<AttendanceUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<AttendanceUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: Enumerable<AttendanceWhereUniqueInput>
    disconnect?: Enumerable<AttendanceWhereUniqueInput>
    delete?: Enumerable<AttendanceWhereUniqueInput>
    connect?: Enumerable<AttendanceWhereUniqueInput>
    update?: Enumerable<AttendanceUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<AttendanceUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<AttendanceScalarWhereInput>
  }

  export type SalaryUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<SalaryCreateWithoutEmployeeInput>, Enumerable<SalaryUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<SalaryCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<SalaryUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: Enumerable<SalaryWhereUniqueInput>
    disconnect?: Enumerable<SalaryWhereUniqueInput>
    delete?: Enumerable<SalaryWhereUniqueInput>
    connect?: Enumerable<SalaryWhereUniqueInput>
    update?: Enumerable<SalaryUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<SalaryUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<SalaryScalarWhereInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutEmployeeInput>, Enumerable<AttendanceUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<AttendanceUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: Enumerable<AttendanceWhereUniqueInput>
    disconnect?: Enumerable<AttendanceWhereUniqueInput>
    delete?: Enumerable<AttendanceWhereUniqueInput>
    connect?: Enumerable<AttendanceWhereUniqueInput>
    update?: Enumerable<AttendanceUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<AttendanceUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<AttendanceScalarWhereInput>
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type EmployeeUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutDepartmentsInput = {
    create?: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsInput
    upsert?: UserUpsertWithoutDepartmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDepartmentsInput, UserUncheckedUpdateWithoutDepartmentsInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type SalaryCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<SalaryCreateWithoutAttendanceInput, SalaryUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutAttendanceInput
    connect?: SalaryWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type SalaryUpdateOneWithoutAttendanceInput = {
    create?: XOR<SalaryCreateWithoutAttendanceInput, SalaryUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: SalaryCreateOrConnectWithoutAttendanceInput
    upsert?: SalaryUpsertWithoutAttendanceInput
    disconnect?: boolean
    delete?: boolean
    connect?: SalaryWhereUniqueInput
    update?: XOR<SalaryUpdateWithoutAttendanceInput, SalaryUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeUpdateOneWithoutAttendanceInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    upsert?: EmployeeUpsertWithoutAttendanceInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type AttendanceCreateNestedManyWithoutSalaryInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutSalaryInput>, Enumerable<AttendanceUncheckedCreateWithoutSalaryInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutSalaryInput>
    createMany?: AttendanceCreateManySalaryInputEnvelope
    connect?: Enumerable<AttendanceWhereUniqueInput>
  }

  export type EmployeeCreateNestedOneWithoutSalaryInput = {
    create?: XOR<EmployeeCreateWithoutSalaryInput, EmployeeUncheckedCreateWithoutSalaryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSalaryInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutSalaryInput>, Enumerable<AttendanceUncheckedCreateWithoutSalaryInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutSalaryInput>
    createMany?: AttendanceCreateManySalaryInputEnvelope
    connect?: Enumerable<AttendanceWhereUniqueInput>
  }

  export type AttendanceUpdateManyWithoutSalaryInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutSalaryInput>, Enumerable<AttendanceUncheckedCreateWithoutSalaryInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutSalaryInput>
    upsert?: Enumerable<AttendanceUpsertWithWhereUniqueWithoutSalaryInput>
    createMany?: AttendanceCreateManySalaryInputEnvelope
    set?: Enumerable<AttendanceWhereUniqueInput>
    disconnect?: Enumerable<AttendanceWhereUniqueInput>
    delete?: Enumerable<AttendanceWhereUniqueInput>
    connect?: Enumerable<AttendanceWhereUniqueInput>
    update?: Enumerable<AttendanceUpdateWithWhereUniqueWithoutSalaryInput>
    updateMany?: Enumerable<AttendanceUpdateManyWithWhereWithoutSalaryInput>
    deleteMany?: Enumerable<AttendanceScalarWhereInput>
  }

  export type EmployeeUpdateOneRequiredWithoutSalaryInput = {
    create?: XOR<EmployeeCreateWithoutSalaryInput, EmployeeUncheckedCreateWithoutSalaryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryInput
    upsert?: EmployeeUpsertWithoutSalaryInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutSalaryInput, EmployeeUncheckedUpdateWithoutSalaryInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutSalaryInput = {
    create?: XOR<Enumerable<AttendanceCreateWithoutSalaryInput>, Enumerable<AttendanceUncheckedCreateWithoutSalaryInput>>
    connectOrCreate?: Enumerable<AttendanceCreateOrConnectWithoutSalaryInput>
    upsert?: Enumerable<AttendanceUpsertWithWhereUniqueWithoutSalaryInput>
    createMany?: AttendanceCreateManySalaryInputEnvelope
    set?: Enumerable<AttendanceWhereUniqueInput>
    disconnect?: Enumerable<AttendanceWhereUniqueInput>
    delete?: Enumerable<AttendanceWhereUniqueInput>
    connect?: Enumerable<AttendanceWhereUniqueInput>
    update?: Enumerable<AttendanceUpdateWithWhereUniqueWithoutSalaryInput>
    updateMany?: Enumerable<AttendanceUpdateManyWithWhereWithoutSalaryInput>
    deleteMany?: Enumerable<AttendanceScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserCreateWithoutPermissionInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    expenses?: ExpansesCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    departments?: DepartmentCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateWithoutPermissionInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpansesUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserCreateOrConnectWithoutPermissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionInput, UserUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    roleId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: Enumerable<RolePermissionCreateManyPermissionInput>
  }

  export type UserUpsertWithoutPermissionInput = {
    update: XOR<UserUpdateWithoutPermissionInput, UserUncheckedUpdateWithoutPermissionInput>
    create: XOR<UserCreateWithoutPermissionInput, UserUncheckedCreateWithoutPermissionInput>
  }

  export type UserUpdateWithoutPermissionInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserInput
    expenses?: ExpansesUpdateManyWithoutUserInput
    employees?: EmployeeUpdateManyWithoutUserInput
    departments?: DepartmentUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutPermissionInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserInput
    expenses?: ExpansesUncheckedUpdateManyWithoutUserInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserInput
    departments?: DepartmentUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRolePermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: Enumerable<RolePermissionScalarWhereInput>
    OR?: Enumerable<RolePermissionScalarWhereInput>
    NOT?: Enumerable<RolePermissionScalarWhereInput>
    id?: StringFilter | string
    roleId?: StringNullableFilter | string | null
    permissionId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: Enumerable<AddressCreateManyUserInput>
  }

  export type PermissionsCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    RolePermission?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionsUncheckedCreateWithoutUserInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    RolePermission?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionsCreateOrConnectWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsCreateManyUserInputEnvelope = {
    data: Enumerable<PermissionsCreateManyUserInput>
  }

  export type ExpansesCreateWithoutUserInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesCreateOrConnectWithoutUserInput = {
    where: ExpansesWhereUniqueInput
    create: XOR<ExpansesCreateWithoutUserInput, ExpansesUncheckedCreateWithoutUserInput>
  }

  export type ExpansesCreateManyUserInputEnvelope = {
    data: Enumerable<ExpansesCreateManyUserInput>
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    title?: string | null
    department: DepartmentCreateNestedOneWithoutEmployeesInput
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryCreateNestedManyWithoutEmployeeInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateManyUserInputEnvelope = {
    data: Enumerable<EmployeeCreateManyUserInput>
  }

  export type DepartmentCreateWithoutUserInput = {
    id?: string
    title?: string | null
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentCreateOrConnectWithoutUserInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
  }

  export type DepartmentCreateManyUserInputEnvelope = {
    data: Enumerable<DepartmentCreateManyUserInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: StringFilter | string
    type?: StringNullableFilter | string | null
    addressTitle?: StringNullableFilter | string | null
    addressLine?: StringNullableFilter | string | null
    addressLine1?: StringNullableFilter | string | null
    addressLine2?: StringNullableFilter | string | null
    landmark?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    pincode?: StringNullableFilter | string | null
    mobile?: StringNullableFilter | string | null
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type PermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutUserInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PermissionsScalarWhereInput = {
    AND?: Enumerable<PermissionsScalarWhereInput>
    OR?: Enumerable<PermissionsScalarWhereInput>
    NOT?: Enumerable<PermissionsScalarWhereInput>
    id?: StringFilter | string
    slug?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    actions?: StringNullableListFilter
    parents?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
  }

  export type ExpansesUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpansesWhereUniqueInput
    update: XOR<ExpansesUpdateWithoutUserInput, ExpansesUncheckedUpdateWithoutUserInput>
    create: XOR<ExpansesCreateWithoutUserInput, ExpansesUncheckedCreateWithoutUserInput>
  }

  export type ExpansesUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpansesWhereUniqueInput
    data: XOR<ExpansesUpdateWithoutUserInput, ExpansesUncheckedUpdateWithoutUserInput>
  }

  export type ExpansesUpdateManyWithWhereWithoutUserInput = {
    where: ExpansesScalarWhereInput
    data: XOR<ExpansesUpdateManyMutationInput, ExpansesUncheckedUpdateManyWithoutExpensesInput>
  }

  export type ExpansesScalarWhereInput = {
    AND?: Enumerable<ExpansesScalarWhereInput>
    OR?: Enumerable<ExpansesScalarWhereInput>
    NOT?: Enumerable<ExpansesScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    expensesType?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: Enumerable<EmployeeScalarWhereInput>
    OR?: Enumerable<EmployeeScalarWhereInput>
    NOT?: Enumerable<EmployeeScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    departmentId?: StringFilter | string
    monthlyPay?: StringNullableFilter | string | null
    yearlyPay?: StringNullableFilter | string | null
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutUserInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutUserInput, DepartmentUncheckedUpdateWithoutUserInput>
    create: XOR<DepartmentCreateWithoutUserInput, DepartmentUncheckedCreateWithoutUserInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutUserInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutUserInput, DepartmentUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutUserInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: Enumerable<DepartmentScalarWhereInput>
    OR?: Enumerable<DepartmentScalarWhereInput>
    NOT?: Enumerable<DepartmentScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    userId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type ProductCreateWithoutWarehouseInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    shelf: ShelfCreateNestedOneWithoutProductInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUncheckedCreateWithoutWarehouseInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    shelfId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductCreateOrConnectWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductCreateManyWarehouseInputEnvelope = {
    data: Enumerable<ProductCreateManyWarehouseInput>
  }

  export type RacksCreateWithoutWarehouseInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    shelf?: ShelfCreateNestedManyWithoutRacksInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksUncheckedCreateWithoutWarehouseInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    shelf?: ShelfUncheckedCreateNestedManyWithoutRacksInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksCreateOrConnectWithoutWarehouseInput = {
    where: RacksWhereUniqueInput
    create: XOR<RacksCreateWithoutWarehouseInput, RacksUncheckedCreateWithoutWarehouseInput>
  }

  export type RacksCreateManyWarehouseInputEnvelope = {
    data: Enumerable<RacksCreateManyWarehouseInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutWarehouseInput, ProductUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductCreateWithoutWarehouseInput, ProductUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutWarehouseInput, ProductUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    bulletPoints?: StringNullableListFilter
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    quantity?: StringNullableListFilter
    purchase_price?: StringNullableListFilter
    userId?: StringNullableFilter | string | null
    warehouseId?: StringFilter | string
    shelfId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type RacksUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: RacksWhereUniqueInput
    update: XOR<RacksUpdateWithoutWarehouseInput, RacksUncheckedUpdateWithoutWarehouseInput>
    create: XOR<RacksCreateWithoutWarehouseInput, RacksUncheckedCreateWithoutWarehouseInput>
  }

  export type RacksUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: RacksWhereUniqueInput
    data: XOR<RacksUpdateWithoutWarehouseInput, RacksUncheckedUpdateWithoutWarehouseInput>
  }

  export type RacksUpdateManyWithWhereWithoutWarehouseInput = {
    where: RacksScalarWhereInput
    data: XOR<RacksUpdateManyMutationInput, RacksUncheckedUpdateManyWithoutRacksInput>
  }

  export type RacksScalarWhereInput = {
    AND?: Enumerable<RacksScalarWhereInput>
    OR?: Enumerable<RacksScalarWhereInput>
    NOT?: Enumerable<RacksScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    side?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    warehouseId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type ShelfCreateWithoutRacksInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    Product?: ProductCreateNestedManyWithoutShelfInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUncheckedCreateWithoutRacksInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutShelfInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfCreateOrConnectWithoutRacksInput = {
    where: ShelfWhereUniqueInput
    create: XOR<ShelfCreateWithoutRacksInput, ShelfUncheckedCreateWithoutRacksInput>
  }

  export type ShelfCreateManyRacksInputEnvelope = {
    data: Enumerable<ShelfCreateManyRacksInput>
  }

  export type WarehouseCreateWithoutRacksInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    products?: ProductCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutRacksInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutRacksInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutRacksInput, WarehouseUncheckedCreateWithoutRacksInput>
  }

  export type ShelfUpsertWithWhereUniqueWithoutRacksInput = {
    where: ShelfWhereUniqueInput
    update: XOR<ShelfUpdateWithoutRacksInput, ShelfUncheckedUpdateWithoutRacksInput>
    create: XOR<ShelfCreateWithoutRacksInput, ShelfUncheckedCreateWithoutRacksInput>
  }

  export type ShelfUpdateWithWhereUniqueWithoutRacksInput = {
    where: ShelfWhereUniqueInput
    data: XOR<ShelfUpdateWithoutRacksInput, ShelfUncheckedUpdateWithoutRacksInput>
  }

  export type ShelfUpdateManyWithWhereWithoutRacksInput = {
    where: ShelfScalarWhereInput
    data: XOR<ShelfUpdateManyMutationInput, ShelfUncheckedUpdateManyWithoutShelfInput>
  }

  export type ShelfScalarWhereInput = {
    AND?: Enumerable<ShelfScalarWhereInput>
    OR?: Enumerable<ShelfScalarWhereInput>
    NOT?: Enumerable<ShelfScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    code?: StringNullableFilter | string | null
    length?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
    side?: StringNullableFilter | string | null
    totalSpace?: StringNullableFilter | string | null
    availableSpace?: StringNullableFilter | string | null
    rackId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type WarehouseUpsertWithoutRacksInput = {
    update: XOR<WarehouseUpdateWithoutRacksInput, WarehouseUncheckedUpdateWithoutRacksInput>
    create: XOR<WarehouseCreateWithoutRacksInput, WarehouseUncheckedCreateWithoutRacksInput>
  }

  export type WarehouseUpdateWithoutRacksInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedUpdateWithoutRacksInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutWarehouseInput
  }

  export type ProductCreateWithoutShelfInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouse: WarehouseCreateNestedOneWithoutProductsInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUncheckedCreateWithoutShelfInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouseId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductCreateOrConnectWithoutShelfInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutShelfInput, ProductUncheckedCreateWithoutShelfInput>
  }

  export type ProductCreateManyShelfInputEnvelope = {
    data: Enumerable<ProductCreateManyShelfInput>
  }

  export type RacksCreateWithoutShelfInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    userId?: string | null
    warehouse: WarehouseCreateNestedOneWithoutRacksInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksUncheckedCreateWithoutShelfInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    userId?: string | null
    warehouseId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksCreateOrConnectWithoutShelfInput = {
    where: RacksWhereUniqueInput
    create: XOR<RacksCreateWithoutShelfInput, RacksUncheckedCreateWithoutShelfInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutShelfInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutShelfInput, ProductUncheckedUpdateWithoutShelfInput>
    create: XOR<ProductCreateWithoutShelfInput, ProductUncheckedCreateWithoutShelfInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutShelfInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutShelfInput, ProductUncheckedUpdateWithoutShelfInput>
  }

  export type ProductUpdateManyWithWhereWithoutShelfInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type RacksUpsertWithoutShelfInput = {
    update: XOR<RacksUpdateWithoutShelfInput, RacksUncheckedUpdateWithoutShelfInput>
    create: XOR<RacksCreateWithoutShelfInput, RacksUncheckedCreateWithoutShelfInput>
  }

  export type RacksUpdateWithoutShelfInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutRacksInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUncheckedUpdateWithoutShelfInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateWithoutProductsInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    racks?: RacksCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutProductsInput = {
    id?: string
    title?: string | null
    staff?: string | null
    addressId?: WarehouseCreateaddressIdInput | Enumerable<string>
    incharge?: string | null
    userId?: string | null
    racks?: RacksUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutProductsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutProductsInput, WarehouseUncheckedCreateWithoutProductsInput>
  }

  export type ShelfCreateWithoutProductInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    racks: RacksCreateNestedOneWithoutShelfInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUncheckedCreateWithoutProductInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    rackId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfCreateOrConnectWithoutProductInput = {
    where: ShelfWhereUniqueInput
    create: XOR<ShelfCreateWithoutProductInput, ShelfUncheckedCreateWithoutProductInput>
  }

  export type WarehouseUpsertWithoutProductsInput = {
    update: XOR<WarehouseUpdateWithoutProductsInput, WarehouseUncheckedUpdateWithoutProductsInput>
    create: XOR<WarehouseCreateWithoutProductsInput, WarehouseUncheckedCreateWithoutProductsInput>
  }

  export type WarehouseUpdateWithoutProductsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    racks?: RacksUpdateManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedUpdateWithoutProductsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: WarehouseUpdateaddressIdInput | Enumerable<string>
    incharge?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    racks?: RacksUncheckedUpdateManyWithoutWarehouseInput
  }

  export type ShelfUpsertWithoutProductInput = {
    update: XOR<ShelfUpdateWithoutProductInput, ShelfUncheckedUpdateWithoutProductInput>
    create: XOR<ShelfCreateWithoutProductInput, ShelfUncheckedCreateWithoutProductInput>
  }

  export type ShelfUpdateWithoutProductInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    racks?: RacksUpdateOneRequiredWithoutShelfInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfUncheckedUpdateWithoutProductInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    rackId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsCreateWithoutRolePermissionInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    User?: UserCreateNestedOneWithoutPermissionInput
  }

  export type PermissionsUncheckedCreateWithoutRolePermissionInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    userId?: string | null
  }

  export type PermissionsCreateOrConnectWithoutRolePermissionInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutRolePermissionInput, PermissionsUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermissionsUpsertWithoutRolePermissionInput = {
    update: XOR<PermissionsUpdateWithoutRolePermissionInput, PermissionsUncheckedUpdateWithoutRolePermissionInput>
    create: XOR<PermissionsCreateWithoutRolePermissionInput, PermissionsUncheckedCreateWithoutRolePermissionInput>
  }

  export type PermissionsUpdateWithoutRolePermissionInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutPermissionInput
  }

  export type PermissionsUncheckedUpdateWithoutRolePermissionInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type POItemsCreateWithoutPoInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsUncheckedCreateWithoutPoInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsCreateOrConnectWithoutPoInput = {
    where: POItemsWhereUniqueInput
    create: XOR<POItemsCreateWithoutPoInput, POItemsUncheckedCreateWithoutPoInput>
  }

  export type POItemsCreateManyPoInputEnvelope = {
    data: Enumerable<POItemsCreateManyPoInput>
  }

  export type POItemsUpsertWithWhereUniqueWithoutPoInput = {
    where: POItemsWhereUniqueInput
    update: XOR<POItemsUpdateWithoutPoInput, POItemsUncheckedUpdateWithoutPoInput>
    create: XOR<POItemsCreateWithoutPoInput, POItemsUncheckedCreateWithoutPoInput>
  }

  export type POItemsUpdateWithWhereUniqueWithoutPoInput = {
    where: POItemsWhereUniqueInput
    data: XOR<POItemsUpdateWithoutPoInput, POItemsUncheckedUpdateWithoutPoInput>
  }

  export type POItemsUpdateManyWithWhereWithoutPoInput = {
    where: POItemsScalarWhereInput
    data: XOR<POItemsUpdateManyMutationInput, POItemsUncheckedUpdateManyWithoutPoItemInput>
  }

  export type POItemsScalarWhereInput = {
    AND?: Enumerable<POItemsScalarWhereInput>
    OR?: Enumerable<POItemsScalarWhereInput>
    NOT?: Enumerable<POItemsScalarWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    poId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type POCreateWithoutPoItemInput = {
    id?: string
    poStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    userId?: string | null
    vendorId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POUncheckedCreateWithoutPoItemInput = {
    id?: string
    poStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    userId?: string | null
    vendorId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POCreateOrConnectWithoutPoItemInput = {
    where: POWhereUniqueInput
    create: XOR<POCreateWithoutPoItemInput, POUncheckedCreateWithoutPoItemInput>
  }

  export type POUpsertWithoutPoItemInput = {
    update: XOR<POUpdateWithoutPoItemInput, POUncheckedUpdateWithoutPoItemInput>
    create: XOR<POCreateWithoutPoItemInput, POUncheckedCreateWithoutPoItemInput>
  }

  export type POUpdateWithoutPoItemInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POUncheckedUpdateWithoutPoItemInput = {
    poStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsCreateWithoutInvoiceInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsUncheckedCreateWithoutInvoiceInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemsWhereUniqueInput
    create: XOR<InvoiceItemsCreateWithoutInvoiceInput, InvoiceItemsUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemsCreateManyInvoiceInputEnvelope = {
    data: Enumerable<InvoiceItemsCreateManyInvoiceInput>
  }

  export type InvoiceItemsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemsWhereUniqueInput
    update: XOR<InvoiceItemsUpdateWithoutInvoiceInput, InvoiceItemsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemsCreateWithoutInvoiceInput, InvoiceItemsUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemsWhereUniqueInput
    data: XOR<InvoiceItemsUpdateWithoutInvoiceInput, InvoiceItemsUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemsUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemsScalarWhereInput
    data: XOR<InvoiceItemsUpdateManyMutationInput, InvoiceItemsUncheckedUpdateManyWithoutInvoiceItemsInput>
  }

  export type InvoiceItemsScalarWhereInput = {
    AND?: Enumerable<InvoiceItemsScalarWhereInput>
    OR?: Enumerable<InvoiceItemsScalarWhereInput>
    NOT?: Enumerable<InvoiceItemsScalarWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    invoiceId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type InvoiceCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateWithoutInvoiceItemsInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutInvoiceItemsInput = {
    invoiceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateWithoutOrderInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsUncheckedCreateWithoutOrderInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsCreateOrConnectWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemsCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderItemsCreateManyOrderInput>
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutOrderInput, OrderItemsUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemsCreateWithoutOrderInput, OrderItemsUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutOrderInput, OrderItemsUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type OrderItemsScalarWhereInput = {
    AND?: Enumerable<OrderItemsScalarWhereInput>
    OR?: Enumerable<OrderItemsScalarWhereInput>
    NOT?: Enumerable<OrderItemsScalarWhereInput>
    id?: StringFilter | string
    sku?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    short_desc?: StringNullableFilter | string | null
    desc?: StringNullableFilter | string | null
    categories?: StringNullableListFilter
    variation?: StringNullableListFilter
    images?: StringNullableListFilter
    price?: StringNullableListFilter
    taxRate?: StringNullableListFilter
    taxAmount?: StringNullableListFilter
    discountAmount?: StringNullableListFilter
    quantity?: StringNullableListFilter
    orderId?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    orderStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    orderStatus?: string | null
    paymentStatus?: string | null
    paindAmount?: string | null
    pendingAmount?: string | null
    totalPrice?: string | null
    totalTax?: string | null
    totalDiscount?: string | null
    totalTransportation?: string | null
    totalExpenses?: string | null
    buyerId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    paindAmount?: NullableStringFieldUpdateOperationsInput | string | null
    pendingAmount?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableStringFieldUpdateOperationsInput | string | null
    totalDiscount?: NullableStringFieldUpdateOperationsInput | string | null
    totalTransportation?: NullableStringFieldUpdateOperationsInput | string | null
    totalExpenses?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    permission?: PermissionsCreateNestedManyWithoutUserInput
    expenses?: ExpansesCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    departments?: DepartmentCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    permission?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpansesUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: PermissionsUpdateManyWithoutUserInput
    expenses?: ExpansesUpdateManyWithoutUserInput
    employees?: EmployeeUpdateManyWithoutUserInput
    departments?: DepartmentUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: PermissionsUncheckedUpdateManyWithoutUserInput
    expenses?: ExpansesUncheckedUpdateManyWithoutUserInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserInput
    departments?: DepartmentUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutExpensesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    permission?: PermissionsCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    departments?: DepartmentCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateWithoutExpensesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    permission?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserCreateOrConnectWithoutExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
  }

  export type UserUpsertWithoutExpensesInput = {
    update: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
  }

  export type UserUpdateWithoutExpensesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserInput
    permission?: PermissionsUpdateManyWithoutUserInput
    employees?: EmployeeUpdateManyWithoutUserInput
    departments?: DepartmentUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutExpensesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserInput
    permission?: PermissionsUncheckedUpdateManyWithoutUserInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserInput
    departments?: DepartmentUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    id?: string
    title?: string | null
    user: UserCreateNestedOneWithoutDepartmentsInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    title?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type SalaryCreateWithoutEmployeeInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    attendance?: AttendanceCreateNestedManyWithoutSalaryInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSalaryInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryCreateOrConnectWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryCreateManyEmployeeInputEnvelope = {
    data: Enumerable<SalaryCreateManyEmployeeInput>
  }

  export type UserCreateWithoutEmployeesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    permission?: PermissionsCreateNestedManyWithoutUserInput
    expenses?: ExpansesCreateNestedManyWithoutUserInput
    departments?: DepartmentCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateWithoutEmployeesInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    permission?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpansesUncheckedCreateNestedManyWithoutUserInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserCreateOrConnectWithoutEmployeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceCreateWithoutEmployeeInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    Salary?: SalaryCreateNestedOneWithoutAttendanceInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    salaryId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateManyEmployeeInputEnvelope = {
    data: Enumerable<AttendanceCreateManyEmployeeInput>
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDepartmentsInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    update: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    data: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryScalarWhereInput
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyWithoutSalaryInput>
  }

  export type SalaryScalarWhereInput = {
    AND?: Enumerable<SalaryScalarWhereInput>
    OR?: Enumerable<SalaryScalarWhereInput>
    NOT?: Enumerable<SalaryScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    expensesType?: StringNullableFilter | string | null
    amount?: StringNullableFilter | string | null
    from?: StringNullableFilter | string | null
    to?: StringNullableFilter | string | null
    employeeId?: StringFilter | string
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithoutEmployeesInput = {
    update: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
  }

  export type UserUpdateWithoutEmployeesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserInput
    permission?: PermissionsUpdateManyWithoutUserInput
    expenses?: ExpansesUpdateManyWithoutUserInput
    departments?: DepartmentUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutEmployeesInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserInput
    permission?: PermissionsUncheckedUpdateManyWithoutUserInput
    expenses?: ExpansesUncheckedUpdateManyWithoutUserInput
    departments?: DepartmentUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: Enumerable<AttendanceScalarWhereInput>
    OR?: Enumerable<AttendanceScalarWhereInput>
    NOT?: Enumerable<AttendanceScalarWhereInput>
    id?: StringFilter | string
    title?: StringNullableFilter | string | null
    from?: StringNullableFilter | string | null
    to?: StringNullableFilter | string | null
    presents?: StringNullableFilter | string | null
    absents?: StringNullableFilter | string | null
    paidLeaves?: StringNullableFilter | string | null
    salaryId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeFilter | Date | string
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    title?: string | null
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeesInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title?: string | null
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: Enumerable<EmployeeCreateManyDepartmentInput>
  }

  export type UserCreateWithoutDepartmentsInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressCreateNestedManyWithoutUserInput
    permission?: PermissionsCreateNestedManyWithoutUserInput
    expenses?: ExpansesCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    email?: string | null
    name?: string | null
    password?: string | null
    mobile?: string | null
    address?: AddressUncheckedCreateNestedManyWithoutUserInput
    permission?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    expenses?: ExpansesUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    roleId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type UserCreateOrConnectWithoutDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type UserUpsertWithoutDepartmentsInput = {
    update: XOR<UserUpdateWithoutDepartmentsInput, UserUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<UserCreateWithoutDepartmentsInput, UserUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserUpdateWithoutDepartmentsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateManyWithoutUserInput
    permission?: PermissionsUpdateManyWithoutUserInput
    expenses?: ExpansesUpdateManyWithoutUserInput
    employees?: EmployeeUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDepartmentsInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateManyWithoutUserInput
    permission?: PermissionsUncheckedUpdateManyWithoutUserInput
    expenses?: ExpansesUncheckedUpdateManyWithoutUserInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserInput
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateWithoutAttendanceInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    employee: EmployeeCreateNestedOneWithoutSalaryInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    employeeId: string
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryCreateOrConnectWithoutAttendanceInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutAttendanceInput, SalaryUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeCreateWithoutAttendanceInput = {
    id?: string
    title?: string | null
    department: DepartmentCreateNestedOneWithoutEmployeesInput
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeesInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type EmployeeUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    salary?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type EmployeeCreateOrConnectWithoutAttendanceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
  }

  export type SalaryUpsertWithoutAttendanceInput = {
    update: XOR<SalaryUpdateWithoutAttendanceInput, SalaryUncheckedUpdateWithoutAttendanceInput>
    create: XOR<SalaryCreateWithoutAttendanceInput, SalaryUncheckedCreateWithoutAttendanceInput>
  }

  export type SalaryUpdateWithoutAttendanceInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutSalaryInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateWithoutAttendanceInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutAttendanceInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeUpdateWithoutAttendanceInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutEmployeesInput
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeesInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUncheckedUpdateManyWithoutEmployeeInput
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateWithoutSalaryInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    Employee?: EmployeeCreateNestedOneWithoutAttendanceInput
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUncheckedCreateWithoutSalaryInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    employeeId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSalaryInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSalaryInput, AttendanceUncheckedCreateWithoutSalaryInput>
  }

  export type AttendanceCreateManySalaryInputEnvelope = {
    data: Enumerable<AttendanceCreateManySalaryInput>
  }

  export type EmployeeCreateWithoutSalaryInput = {
    id?: string
    title?: string | null
    department: DepartmentCreateNestedOneWithoutEmployeesInput
    monthlyPay?: string | null
    yearlyPay?: string | null
    user: UserCreateNestedOneWithoutEmployeesInput
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSalaryInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSalaryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalaryInput, EmployeeUncheckedCreateWithoutSalaryInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSalaryInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSalaryInput, AttendanceUncheckedUpdateWithoutSalaryInput>
    create: XOR<AttendanceCreateWithoutSalaryInput, AttendanceUncheckedCreateWithoutSalaryInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSalaryInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSalaryInput, AttendanceUncheckedUpdateWithoutSalaryInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSalaryInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutAttendanceInput>
  }

  export type EmployeeUpsertWithoutSalaryInput = {
    update: XOR<EmployeeUpdateWithoutSalaryInput, EmployeeUncheckedUpdateWithoutSalaryInput>
    create: XOR<EmployeeCreateWithoutSalaryInput, EmployeeUncheckedCreateWithoutSalaryInput>
  }

  export type EmployeeUpdateWithoutSalaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutEmployeesInput
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEmployeesInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutSalaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeInput
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRolePermissionInput = {
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyUserInput = {
    id?: string
    type?: string | null
    addressTitle?: string | null
    addressLine?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    landmark?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    mobile?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type PermissionsCreateManyUserInput = {
    id?: string
    slug?: string | null
    title?: string | null
    actions?: PermissionsCreateactionsInput | Enumerable<string>
    parents?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ExpansesCreateManyUserInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type EmployeeCreateManyUserInput = {
    id?: string
    title?: string | null
    departmentId: string
    monthlyPay?: string | null
    yearlyPay?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type DepartmentCreateManyUserInput = {
    id?: string
    title?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutAddressInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    addressTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUpdateWithoutUserInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    RolePermission?: RolePermissionUpdateManyWithoutPermissionInput
  }

  export type PermissionsUncheckedUpdateWithoutUserInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    RolePermission?: RolePermissionUncheckedUpdateManyWithoutPermissionInput
  }

  export type PermissionsUncheckedUpdateManyWithoutPermissionInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    actions?: PermissionsUpdateactionsInput | Enumerable<string>
    parents?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesUncheckedUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpansesUncheckedUpdateManyWithoutExpensesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneRequiredWithoutEmployeesInput
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUpdateManyWithoutEmployeeInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUncheckedUpdateManyWithoutEmployeeInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUpdateManyWithoutDepartmentInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyWithoutDepartmentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyWarehouseInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    shelfId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type RacksCreateManyWarehouseInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUpdateWithoutWarehouseInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: ShelfUpdateOneRequiredWithoutProductInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutWarehouseInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shelfId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    shelfId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUpdateWithoutWarehouseInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: ShelfUpdateManyWithoutRacksInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUncheckedUpdateWithoutWarehouseInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    shelf?: ShelfUncheckedUpdateManyWithoutRacksInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RacksUncheckedUpdateManyWithoutRacksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfCreateManyRacksInput = {
    id?: string
    name?: string | null
    code?: string | null
    length?: string | null
    width?: string | null
    height?: string | null
    side?: string | null
    totalSpace?: string | null
    availableSpace?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ShelfUpdateWithoutRacksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutShelfInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfUncheckedUpdateWithoutRacksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutShelfInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShelfUncheckedUpdateManyWithoutShelfInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    side?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpace?: NullableStringFieldUpdateOperationsInput | string | null
    availableSpace?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyShelfInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    bulletPoints?: ProductCreatebulletPointsInput | Enumerable<string>
    categories?: ProductCreatecategoriesInput | Enumerable<string>
    variation?: ProductCreatevariationInput | Enumerable<string>
    images?: ProductCreateimagesInput | Enumerable<string>
    price?: ProductCreatepriceInput | Enumerable<string>
    quantity?: ProductCreatequantityInput | Enumerable<string>
    purchase_price?: ProductCreatepurchase_priceInput | Enumerable<string>
    userId?: string | null
    warehouseId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type ProductUpdateWithoutShelfInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutProductsInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutShelfInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    bulletPoints?: ProductUpdatebulletPointsInput | Enumerable<string>
    categories?: ProductUpdatecategoriesInput | Enumerable<string>
    variation?: ProductUpdatevariationInput | Enumerable<string>
    images?: ProductUpdateimagesInput | Enumerable<string>
    price?: ProductUpdatepriceInput | Enumerable<string>
    quantity?: ProductUpdatequantityInput | Enumerable<string>
    purchase_price?: ProductUpdatepurchase_priceInput | Enumerable<string>
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsCreateManyPoInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: POItemsCreatecategoriesInput | Enumerable<string>
    variation?: POItemsCreatevariationInput | Enumerable<string>
    images?: POItemsCreateimagesInput | Enumerable<string>
    price?: POItemsCreatepriceInput | Enumerable<string>
    taxRate?: POItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: POItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type POItemsUpdateWithoutPoInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsUncheckedUpdateWithoutPoInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POItemsUncheckedUpdateManyWithoutPoItemInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: POItemsUpdatecategoriesInput | Enumerable<string>
    variation?: POItemsUpdatevariationInput | Enumerable<string>
    images?: POItemsUpdateimagesInput | Enumerable<string>
    price?: POItemsUpdatepriceInput | Enumerable<string>
    taxRate?: POItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: POItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: POItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: POItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsCreateManyInvoiceInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: InvoiceItemsCreatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsCreatevariationInput | Enumerable<string>
    images?: InvoiceItemsCreateimagesInput | Enumerable<string>
    price?: InvoiceItemsCreatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type InvoiceItemsUpdateWithoutInvoiceInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsUncheckedUpdateWithoutInvoiceInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemsUncheckedUpdateManyWithoutInvoiceItemsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: InvoiceItemsUpdatecategoriesInput | Enumerable<string>
    variation?: InvoiceItemsUpdatevariationInput | Enumerable<string>
    images?: InvoiceItemsUpdateimagesInput | Enumerable<string>
    price?: InvoiceItemsUpdatepriceInput | Enumerable<string>
    taxRate?: InvoiceItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: InvoiceItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: InvoiceItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: InvoiceItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsCreateManyOrderInput = {
    id?: string
    sku?: string | null
    title?: string | null
    short_desc?: string | null
    desc?: string | null
    categories?: OrderItemsCreatecategoriesInput | Enumerable<string>
    variation?: OrderItemsCreatevariationInput | Enumerable<string>
    images?: OrderItemsCreateimagesInput | Enumerable<string>
    price?: OrderItemsCreatepriceInput | Enumerable<string>
    taxRate?: OrderItemsCreatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsCreatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsCreatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsCreatequantityInput | Enumerable<string>
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type OrderItemsUpdateWithoutOrderInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateWithoutOrderInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrderItemsInput = {
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    short_desc?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: OrderItemsUpdatecategoriesInput | Enumerable<string>
    variation?: OrderItemsUpdatevariationInput | Enumerable<string>
    images?: OrderItemsUpdateimagesInput | Enumerable<string>
    price?: OrderItemsUpdatepriceInput | Enumerable<string>
    taxRate?: OrderItemsUpdatetaxRateInput | Enumerable<string>
    taxAmount?: OrderItemsUpdatetaxAmountInput | Enumerable<string>
    discountAmount?: OrderItemsUpdatediscountAmountInput | Enumerable<string>
    quantity?: OrderItemsUpdatequantityInput | Enumerable<string>
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateManyEmployeeInput = {
    id?: string
    title?: string | null
    expensesType?: string | null
    amount?: string | null
    from?: string | null
    to?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceCreateManyEmployeeInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    salaryId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type SalaryUpdateWithoutEmployeeInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUpdateManyWithoutSalaryInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateWithoutEmployeeInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: AttendanceUncheckedUpdateManyWithoutSalaryInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateManyWithoutSalaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    expensesType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutEmployeeInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: SalaryUpdateOneWithoutAttendanceInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutEmployeeInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    salaryId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutAttendanceInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    salaryId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    title?: string | null
    monthlyPay?: string | null
    yearlyPay?: string | null
    userId: string
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUpdateManyWithoutEmployeeInput
    user?: UserUpdateOneRequiredWithoutEmployeesInput
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyPay?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: SalaryUncheckedUpdateManyWithoutEmployeeInput
    userId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeInput
  }

  export type AttendanceCreateManySalaryInput = {
    id?: string
    title?: string | null
    from?: string | null
    to?: string | null
    presents?: string | null
    absents?: string | null
    paidLeaves?: string | null
    employeeId?: string | null
    userId?: string | null
    created_at: Date | string
    updated_at: Date | string
    deleted_at: Date | string
  }

  export type AttendanceUpdateWithoutSalaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    Employee?: EmployeeUpdateOneWithoutAttendanceInput
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutSalaryInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    from?: NullableStringFieldUpdateOperationsInput | string | null
    to?: NullableStringFieldUpdateOperationsInput | string | null
    presents?: NullableStringFieldUpdateOperationsInput | string | null
    absents?: NullableStringFieldUpdateOperationsInput | string | null
    paidLeaves?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}